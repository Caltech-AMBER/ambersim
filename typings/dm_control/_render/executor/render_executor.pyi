"""
This type stub file was generated by pyright.
"""

import abc
import contextlib

"""RenderExecutors executes OpenGL rendering calls on an appropriate thread.

The purpose of these classes is to ensure that OpenGL calls are made on the
same thread as where an OpenGL context was made current.

In a single-threaded setting, `PassthroughRenderExecutor` is essentially a no-op
that executes rendering calls on the same thread. This is provided to minimize
thread-switching overhead.

In a multithreaded setting, `OffloadingRenderExecutor` maintains a separate
dedicated thread on which the OpenGL context is created and made current. All
subsequent rendering calls are then offloaded onto this dedicated thread.
"""
_NOT_IN_CONTEXT = ...
_ALREADY_TERMINATED = ...

class _FakeLock:
    """An object with the same API as `threading.Lock` but that does nothing."""

    def acquire(self, blocking=...):  # -> None:
        ...
    def release(self):  # -> None:
        ...
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, exc_type, exc_value, traceback):  # -> None:
        ...

_FAKE_LOCK = ...

class BaseRenderExecutor(metaclass=abc.ABCMeta):
    """An object that manages rendering calls for an OpenGL context.

    This class helps ensure that OpenGL calls are made on the correct thread. The
    usage pattern is as follows:

    ```python
    executor = SomeRenderExecutorClass()
    with executor.execution_context() as ctx:
      ctx.call(an_opengl_call, arg, kwarg=foo)
      result = ctx.call(another_opengl_call)
    ```
    """

    def __init__(self) -> None: ...
    @contextlib.contextmanager
    def execution_context(self):  # -> Generator[Self@BaseRenderExecutor, Any, None]:
        """A context manager that allows calls to be offloaded to this executor."""
        ...
    @property
    def terminated(self):  # -> bool:
        ...
    @property
    @abc.abstractmethod
    def thread(self):  # -> None:
        ...
    @abc.abstractmethod
    def call(self, *args, **kwargs):  # -> None:
        ...
    @abc.abstractmethod
    def terminate(self, cleanup_callable=...):  # -> None:
        ...

class PassthroughRenderExecutor(BaseRenderExecutor):
    """A no-op render executor that executes on the calling thread."""

    def __init__(self) -> None: ...
    @property
    def thread(self):  # -> Thread | None:
        ...
    def call(self, func, *args, **kwargs): ...
    def terminate(self, cleanup_callable=...):  # -> None:
        ...

class _ThreadPoolExecutorPool:
    """A pool of reusable ThreadPoolExecutors."""

    def __init__(self) -> None: ...
    def acquire(self):  # -> ThreadPoolExecutor:
        ...
    def release(self, thread_pool_executor):  # -> None:
        ...

_THREAD_POOL_EXECUTOR_POOL = ...

class OffloadingRenderExecutor(BaseRenderExecutor):
    """A render executor that executes calls on a dedicated offload thread."""

    def __init__(self) -> None: ...
    @property
    def thread(self):  # -> Thread | None:
        ...
    def call(self, func, *args, **kwargs): ...
    def terminate(self, cleanup_callable=...):  # -> None:
        ...

"""
This type stub file was generated by pyright.
"""

import abc

"""Module defining the abstract entity class."""
_OPTION_KEYS = ...
_NO_ATTACHMENT_FRAME = ...

class _ObservableKeys:
    """Helper object that implements the `observables.dict_keys` functionality."""

    def __init__(self, entity, observables) -> None: ...
    def __getattr__(self, name): ...
    def __dir__(self):  # -> list[Unknown]:
        ...

class Observables:
    """Base-class for Entity observables.

    Subclasses should declare getter methods annotated with @define.observable
    decorator and returning an observable object.
    """

    def __init__(self, entity) -> None: ...
    @property
    def dict_keys(self):  # -> _ObservableKeys:
        ...
    def as_dict(self, fully_qualified=...):  # -> OrderedDict[Unknown, Unknown]:
        """Returns an OrderedDict of observables belonging to this Entity.

        The returned observables will include any added using the _add_observable
        method, as well as any generated by a method decorated with the
        @define.observable annotation.

        Args:
          fully_qualified: (bool) Whether the dict keys should be prefixed with the
            parent entity's full model identifier.
        """
        ...
    def get_observable(self, name, name_fully_qualified=...):
        """Returns the observable with the given name.

        Args:
          name: (str) The identifier of the observable.
          name_fully_qualified: (bool) Whether the provided name is prefixed by the
            model's full identifier.
        """
        ...
    def set_options(self, options):  # -> None:
        """Configure Observables with an options dict.

        Args:
          options: A dict of dicts of configuration options keyed on
            observable names, or a dict of configuration options, which will
            propagate those options to all observables.
        """
        ...
    def enable_all(self):  # -> None:
        """Enable all observables of this entity."""
        ...
    def disable_all(self):  # -> None:
        """Disable all observables of this entity."""
        ...
    def add_observable(self, name, observable, enabled=...):  # -> None:
        ...

class FreePropObservableMixin(metaclass=abc.ABCMeta):
    """Enforce observables of a free-moving object."""

    @property
    @abc.abstractmethod
    def position(self):  # -> None:
        ...
    @property
    @abc.abstractmethod
    def orientation(self):  # -> None:
        ...
    @property
    @abc.abstractmethod
    def linear_velocity(self):  # -> None:
        ...
    @property
    @abc.abstractmethod
    def angular_velocity(self):  # -> None:
        ...

class Entity(metaclass=abc.ABCMeta):
    """The abstract base class for an entity in a Composer environment."""

    def __init__(self, *args, **kwargs) -> None:
        """Entity constructor.

        Subclasses should not override this method, instead implement a _build
        method.

        Args:
          *args: Arguments passed through to the _build method.
          **kwargs: Keyword arguments. Passed through to the _build method, apart
            from the following.
              `observable_options`: A dictionary of Observable
                configuration options.
        """
        ...
    def iter_entities(self, exclude_self=...):  # -> Generator[Self@Entity | Unknown, Any, None]:
        """An iterator that recursively iterates through all attached entities.

        Args:
          exclude_self: (optional) Whether to exclude this `Entity` itself from the
            iterator.

        Yields:
          If `exclude_self` is `False`, the first value yielded is this Entity
          itself. The following Entities are then yielded recursively in a
          depth-first fashion, following the order in which the Entities are
          attached.
        """
        ...
    @property
    def observables(self):  # -> Observables:
        """The observables defined by this entity."""
        ...
    def initialize_episode_mjcf(self, random_state):  # -> None:
        """Callback executed when the MJCF model is modified between episodes."""
        ...
    def after_compile(self, physics, random_state):  # -> None:
        """Callback executed after the Mujoco Physics is recompiled."""
        ...
    def initialize_episode(self, physics, random_state):  # -> None:
        """Callback executed during episode initialization."""
        ...
    def before_step(self, physics, random_state):  # -> None:
        """Callback executed before an agent control step."""
        ...
    def before_substep(self, physics, random_state):  # -> None:
        """Callback executed before a simulation step."""
        ...
    def after_substep(self, physics, random_state):  # -> None:
        """A callback which is executed after a simulation step."""
        ...
    def after_step(self, physics, random_state):  # -> None:
        """Callback executed after an agent control step."""
        ...
    @property
    @abc.abstractmethod
    def mjcf_model(self): ...
    def attach(self, entity, attach_site=...):
        """Attaches an `Entity` without any additional degrees of freedom.

        Args:
          entity: The `Entity` to attach.
          attach_site: (optional) The site to which to attach the entity's model. If
              not set, defaults to self.attachment_site.

        Returns:
          The frame of the attached model.
        """
        ...
    def detach(self):  # -> None:
        """Detaches this entity if it has previously been attached."""
        ...
    @property
    def parent(self):  # -> None:
        """Returns the `Entity` to which this entity is attached, or `None`."""
        ...
    @property
    def attachment_site(self): ...
    @property
    def root_body(self): ...
    def global_vector_to_local_frame(self, physics, vec_in_world_frame):  # -> Any:
        """Linearly transforms a world-frame vector into entity's local frame.

        Note that this function does not perform an affine transformation of the
        vector. In other words, the input vector is assumed to be specified with
        respect to the same origin as this entity's local frame. This function
        can also be applied to matrices whose innermost dimensions are either 2 or
        3. In this case, a matrix with the same leading dimensions is returned
        where the innermost vectors are replaced by their values computed in the
        local frame.

        Args:
          physics: An `mjcf.Physics` instance.
          vec_in_world_frame: A NumPy array with last dimension of shape (2,) or
          (3,) that represents a vector quantity in the world frame.

        Returns:
          The same quantity as `vec_in_world_frame` but reexpressed in this
          entity's local frame. The returned np.array has the same shape as
          np.asarray(vec_in_world_frame).

        Raises:
          ValueError: if `vec_in_world_frame` does not have shape ending with (2,)
            or (3,).
        """
        ...
    def global_xmat_to_local_frame(self, physics, xmat):  # -> NDArray[Any]:
        """Transforms another entity's `xmat` into this entity's local frame.

        This function takes another entity's (E) xmat, which is an SO(3) matrix
        from E's frame to the world frame, and turns it to a matrix that transforms
        from E's frame into this entity's local frame.

        Args:
          physics: An `mjcf.Physics` instance.
          xmat: A NumPy array of shape (3, 3) or (9,) that represents another
            entity's xmat.

        Returns:
          The `xmat` reexpressed in this entity's local frame. The returned
          np.array has the same shape as np.asarray(xmat).

        Raises:
          ValueError: if `xmat` does not have shape (3, 3) or (9,).
        """
        ...
    def get_pose(self, physics):  # -> tuple[Unknown, Unknown]:
        """Get the position and orientation of this entity relative to its parent.

        Note that the semantics differ slightly depending on whether or not the
        entity has a free joint:

        * If it has a free joint the position and orientation are always given in
          global coordinates.
        * If the entity is fixed or attached with a different joint type then the
          position and orientation are given relative to the parent frame.

        For entities that are either attached directly to the worldbody, or to other
        entities that are positioned at the global origin (e.g. the arena) the
        global and relative poses are equivalent.

        Args:
          physics: An instance of `mjcf.Physics`.

        Returns:
          A 2-tuple where the first entry is a (3,) numpy array representing the
          position and the second is a (4,) numpy array representing orientation as
          a quaternion.

        Raises:
          RuntimeError: If the entity is not attached.
        """
        ...
    def set_pose(self, physics, position=..., quaternion=...):  # -> None:
        """Sets position and/or orientation of this entity relative to its parent.

        If the entity is attached with a free joint, this method will set the
        respective DoFs of the joint. If the entity is either fixed or attached with
        a different joint type, this method will update the position and/or
        quaternion of the attachment frame.

        Note that the semantics differ slightly between the two cases: the DoFs of a
        free body are specified in global coordinates, whereas the position of a
        non-free body is specified in relative coordinates with respect to the
        parent frame. However, for entities that are either attached directly to the
        worldbody, or to other entities that are positioned at the global origin
        (e.g. the arena), there is no difference between the two cases.

        Args:
          physics: An instance of `mjcf.Physics`.
          position: (optional) A NumPy array of size 3.
          quaternion: (optional) A NumPy array of size 4.

        Raises:
          RuntimeError: If the entity is not attached.
        """
        ...
    def shift_pose(self, physics, position=..., quaternion=..., rotate_velocity=...):  # -> None:
        """Shifts the position and/or orientation from its current configuration.

        This is a convenience function that performs the same operation as
        `set_pose`, but where the specified `position` is added to the current
        position, and the specified `quaternion` is premultiplied to the current
        quaternion.

        Args:
          physics: An instance of `mjcf.Physics`.
          position: (optional) A NumPy array of size 3.
          quaternion: (optional) A NumPy array of size 4.
          rotate_velocity: (optional) A bool, whether to shift the current linear
            velocity along with the pose. This will rotate the current linear
            velocity, which is expressed relative to the world frame. The angular
            velocity, which is expressed relative to the local frame is left
            unchanged.

        Raises:
          RuntimeError: If the entity is not attached.
        """
        ...
    def get_velocity(self, physics):  # -> tuple[Unknown, Unknown]:
        """Gets the linear and angular velocity of this free entity.

        Args:
          physics: An instance of `mjcf.Physics`.

        Returns:
          A 2-tuple where the first entry is a (3,) numpy array representing the
          linear velocity and the second is a (3,) numpy array representing the
          angular velocity.

        """
        ...
    def set_velocity(self, physics, velocity=..., angular_velocity=...):  # -> None:
        """Sets the linear velocity and/or angular velocity of this free entity.

        If the entity is attached with a free joint, this method will set the
        respective DoFs of the joint. Otherwise a warning is logged.

        Args:
          physics: An instance of `mjcf.Physics`.
          velocity: (optional) A NumPy array of size 3 specifying the
            linear velocity.
          angular_velocity: (optional) A NumPy array of size 3 specifying the
            angular velocity
        """
        ...
    def configure_joints(self, physics, position):  # -> None:
        """Configures this entity's internal joints.

        The default implementation of this method simply sets the `qpos` of all
        joints in this entity to the values specified in the `position` argument.
        Entity subclasses with actuated joints may override this method to achieve a
        stable reconfiguration of joint positions, for example the control signal
        of position actuators may be changed to match the new joint positions.

        Args:
          physics: An instance of `mjcf.Physics`.
          position: The desired position of this entity's joints.
        """
        ...

class ModelWrapperEntity(Entity):
    """An entity class that wraps an MJCF model without any additional logic."""

    @property
    def mjcf_model(self): ...

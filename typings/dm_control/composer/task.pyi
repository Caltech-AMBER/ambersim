"""
This type stub file was generated by pyright.
"""

import abc

"""Abstract base class for a Composer task."""

class Task(metaclass=abc.ABCMeta):
    """Abstract base class for a Composer task."""

    @abc.abstractproperty
    def root_entity(self):
        """A `base.Entity` instance for this task."""
        ...
    def iter_entities(self): ...
    @property
    def observables(self):  # -> OrderedDict[Unknown, Unknown]:
        """An OrderedDict of `control.Observable` instances for this task.

        Task subclasses should generally NOT override this property.

        This property is automatically computed by combining the observables dict
        provided by each `Entity` present in this task, and any additional
        observables returned via the `task_observables` property.

        To provide an observable to an agent, the task code should either set
        `enabled` property of an `Entity`-bound observable to `True`, or override
        the `task_observables` property to provide additional observables not bound
        to an `Entity`.

        Returns:
          An `collections.OrderedDict` mapping strings to instances of
          `control.Observable`.
        """
        ...
    @property
    def task_observables(self):  # -> OrderedDict[Unknown, Unknown]:
        """An OrderedDict of task-specific `control.Observable` instances.

        A task should override this property if it wants to provide additional
        observables to the agent that are not already provided by any `Entity` that
        forms part of the task's model. For example, this may be used to provide
        observations that is derived from relative poses between two entities.

        Returns:
          An `collections.OrderedDict` mapping strings to instances of
          `control.Observable`.
        """
        ...
    def after_compile(self, physics, random_state):  # -> None:
        """A callback which is executed after the Mujoco Physics is recompiled.

        Args:
          physics: An instance of `control.Physics`.
          random_state: An instance of `np.random.RandomState`.
        """
        ...
    @property
    def control_timestep(self):  # -> float:
        """Returns the agent's control timestep for this task (in seconds)."""
        ...
    @control_timestep.setter
    def control_timestep(self, new_value):  # -> None:
        """Changes the agent's control timestep for this task.

        Args:
          new_value: the new control timestep (in seconds).

        Raises:
          ValueError: if `new_value` is set and is not divisible by
            `physics_timestep`.
        """
        ...
    @property
    def physics_timestep(self):  # -> float:
        """Returns the physics timestep for this task (in seconds)."""
        ...
    @physics_timestep.setter
    def physics_timestep(self, new_value):  # -> None:
        """Changes the physics simulation timestep for this task.

        Args:
          new_value: the new simulation timestep (in seconds).

        Raises:
          ValueError: if `control_timestep` is set and is not divisible by
            `new_value`.
        """
        ...
    def set_timesteps(self, control_timestep, physics_timestep):  # -> None:
        """Changes the agent's control timestep and physics simulation timestep.

        This is equivalent to modifying `control_timestep` and `physics_timestep`
        simultaneously. The divisibility check is performed between the two
        new values.

        Args:
          control_timestep: the new agent's control timestep (in seconds).
          physics_timestep: the new physics simulation timestep (in seconds).

        Raises:
          ValueError: if `control_timestep` is not divisible by `physics_timestep`.
        """
        ...
    @property
    def physics_steps_per_control_step(self):  # -> int:
        """Returns number of physics steps per agent's control step."""
        ...
    def action_spec(self, physics):  # -> BoundedArray:
        """Returns a `BoundedArray` spec matching the `Physics` actuators.

        BoundedArray.name should contain a tab-separated list of actuator names.
        When overloading this method, non-MuJoCo actuators should be added to the
        top of the list when possible, as a matter of convention.

        Args:
          physics: used to query actuator names in the model.
        """
        ...
    def get_reward_spec(self):  # -> None:
        """Optional method to define non-scalar rewards for a `Task`."""
        ...
    def get_discount_spec(self):  # -> None:
        """Optional method to define non-scalar discounts for a `Task`."""
        ...
    def initialize_episode_mjcf(self, random_state):  # -> None:
        """Modifies the MJCF model of this task before the next episode begins.

        The Environment calls this method and recompiles the physics
        if necessary before calling `initialize_episode`.

        Args:
          random_state: An instance of `np.random.RandomState`.
        """
        ...
    def initialize_episode(self, physics, random_state):  # -> None:
        """Modifies the physics state before the next episode begins.

        The Environment calls this method after `initialize_episode_mjcf`, and also
        after the physics has been recompiled if necessary.

        Args:
          physics: An instance of `control.Physics`.
          random_state: An instance of `np.random.RandomState`.
        """
        ...
    def before_step(self, physics, action, random_state):  # -> None:
        """A callback which is executed before an agent control step.

        The default implementation sets the control signal for the actuators in
        `physics` to be equal to `action`. Subclasses that override this method
        should ensure that the overriding method also sets the control signal before
        returning, either by calling `super().before_step`, or by setting
        the control signal explicitly (e.g. in order to create a non-trivial mapping
        between `action` and the control signal).

        Args:
          physics: An instance of `control.Physics`.
          action: A NumPy array corresponding to agent actions.
          random_state: An instance of `np.random.RandomState` (unused).
        """
        ...
    def before_substep(self, physics, action, random_state):  # -> None:
        """A callback which is executed before a simulation step.

        Actuation can be set, or overridden, in this callback.

        Args:
          physics: An instance of `control.Physics`.
          action: A NumPy array corresponding to agent actions.
          random_state: An instance of `np.random.RandomState`.
        """
        ...
    def after_substep(self, physics, random_state):  # -> None:
        """A callback which is executed after a simulation step.

        Args:
          physics: An instance of `control.Physics`.
          random_state: An instance of `np.random.RandomState`.
        """
        ...
    def after_step(self, physics, random_state):  # -> None:
        """A callback which is executed after an agent control step.

        Args:
          physics: An instance of `control.Physics`.
          random_state: An instance of `np.random.RandomState`.
        """
        ...
    @abc.abstractmethod
    def get_reward(self, physics):
        """Calculates the reward signal given the physics state.

        Args:
          physics: A Physics object.

        Returns:
          A float
        """
        ...
    def should_terminate_episode(self, physics):  # -> Literal[False]:
        """Determines whether the episode should terminate given the physics state.

        Args:
          physics: A Physics object

        Returns:
          A boolean
        """
        ...
    def get_discount(self, physics):  # -> float:
        """Calculates the reward discount factor given the physics state.

        Args:
          physics: A Physics object

        Returns:
          A float
        """
        ...

class NullTask(Task):
    """A class that wraps a single `Entity` into a `Task` with no reward."""

    def __init__(self, root_entity) -> None: ...
    @property
    def root_entity(self):  # -> Unknown:
        ...
    def get_reward(self, physics):  # -> float:
        ...

"""
This type stub file was generated by pyright.
"""

from dm_control.mjcf import base

"""
This type stub file was generated by pyright.
"""
_raw_property = ...
_UNITS = ...
_CONFLICT_BEHAVIOR_FUNC = ...

def property(method):
    """Modifies `@property` to keep track of any `AttributeError` raised.

    Our `Element` implementations overrides the `__getattr__` method. This does
    not interact well with `@property`: if a `property`'s code is buggy so as to
    raise an `AttributeError`, then Python would silently discard it and redirect
    to our `__getattr__` instead, leading to an uninformative stack trace. This
    makes it very difficult to debug issues that involve properties.

    To remedy this, we modify `@property` within this module to store any
    `AttributeError` raised within the respective `Element` object. Then, in our
    `__getattr__` logic, we could re-raise it to preserve the original stack
    trace.

    The reason that this is not implemented as a different decorator is that we
    could accidentally use @property on a new method. This would work fine until
    someone triggers a subtle bug. This is when a proper trace would be most
    useful, but we would still end up with a strange undebuggable stack trace
    anyway.

    Note that at the end of this module, we have a `del property` to prevent this
    override from being broadcasted externally.

    Args:
      method: The method that is being decorated.

    Returns:
      A `property` corresponding to the decorated method.
    """
    ...

_DEFAULT_NAME_FROM_FILENAME = ...

class _ElementImpl(base.Element):
    """Actual implementation of a generic MJCF element object."""

    __slots__ = ...
    def __init__(self, spec, parent, attributes=...) -> None: ...
    def get_init_stack(self):
        """Gets the stack trace where this element was first initialized."""
        ...
    def get_last_modified_stacks_for_all_attributes(self):
        """Gets a dict of stack traces where each attribute was last modified."""
        ...
    def is_same_as(self, other):
        """Checks whether another element is semantically equivalent to this one.

        Two elements are considered equivalent if they have the same
        specification (i.e. same tag appearing in the same context), the same
        attribute values, and all of their children are equivalent. The ordering
        of non-repeated children is not important for this comparison, while
        the ordering of repeated children are important only amongst the same
        type* of children. In other words, for two bodies to be considered
        equivalent, their child sites must appear in the same order, and their
        child geoms must appear in the same order, but permutations between sites
        and geoms are disregarded. (The only exception is in tendon definition,
        where strict ordering of all children is necessary for equivalence.)

        *Note that the notion of "same type" in this function is very loose:
        for example different actuator element subtypes are treated as separate
        types when children ordering is considered. Therefore, two <actuator>
        elements might be considered equivalent even though they result in different
        orderings of `mjData.ctrl` when compiled. As it stands, this function
        is designed primarily as a testing aid and should not be used to guarantee
        that models are actually identical.

        Args:
          other: An `mjcf.Element`

        Returns:
          `True` if `other` element is semantically equivalent to this one.
        """
        ...
    @property
    def tag(self): ...
    @property
    def spec(self): ...
    @property
    def parent(self): ...
    @property
    def namescope(self): ...
    @property
    def root(self): ...
    def prefixed_identifier(self, prefix_root): ...
    @property
    def full_identifier(self):
        """Fully-qualified identifier used for this element in the generated XML."""
        ...
    def __dir__(self): ...
    def find(self, namespace, identifier):
        """Finds an element with a particular identifier.

        This function allows the direct access to an arbitrarily deeply nested
        child element by name, without the need to manually traverse through the
        object tree. The `namespace` argument specifies the kind of element to
        find. In most cases, this corresponds to the element's XML tag name.
        However, if an element has multiple specialized tags, then the namespace
        corresponds to the tag name of the most general element of that kind.
        For example, `namespace='joint'` would search for `<joint>` and
        `<freejoint>`, while `namespace='actuator'` would search for `<general>`,
        `<motor>`, `<position>`, `<velocity>`, and `<cylinder>`.

        Args:
          namespace: A string specifying the namespace being searched. See the
            docstring above for explanation.
          identifier: The identifier string of the desired element.

        Returns:
          An `mjcf.Element` object, or `None` if an element with the specified
          identifier is not found.

        Raises:
          ValueError: if either `namespace` or `identifier` is not a string, or if
            `namespace` is not a valid namespace.
        """
        ...
    def find_all(self, namespace, immediate_children_only=..., exclude_attachments=...):
        """Finds all elements of a particular kind.

        The `namespace` argument specifies the kind of element to
        find. In most cases, this corresponds to the element's XML tag name.
        However, if an element has multiple specialized tags, then the namespace
        corresponds to the tag name of the most general element of that kind.
        For example, `namespace='joint'` would search for `<joint>` and
        `<freejoint>`, while `namespace='actuator'` would search for `<general>`,
        `<motor>`, `<position>`, `<velocity>`, and `<cylinder>`.

        Args:
          namespace: A string specifying the namespace being searched. See the
            docstring above for explanation.
          immediate_children_only: (optional) A boolean, if `True` then only
            the immediate children of this element are returned.
          exclude_attachments: (optional) A boolean, if `True` then elements
            belonging to attached models are excluded.

        Returns:
          A list of `mjcf.Element`.

        Raises:
          ValueError: if `namespace` is not a valid namespace.
        """
        ...
    def enter_scope(self, scope_identifier):
        """Finds the root element of the given scope and returns it.

        This function allows the access to a nested scope that is a child of this
        element. The `scope_identifier` argument specifies the path to the child
        scope element.

        Args:
          scope_identifier: The path of the desired scope element.

        Returns:
          An `mjcf.Element` object, or `None` if a scope element with the
          specified path is not found.
        """
        ...
    def get_attribute_xml_string(self, attribute_name, prefix_root=..., *, precision=..., zero_threshold=...): ...
    def get_attributes(self): ...
    def set_attributes(self, **kwargs): ...
    def get_children(self, element_name): ...
    def add(self, element_name, **kwargs):
        """Add a new child element to this element.

        Args:
          element_name: The tag of the element to add.
          **kwargs: Attributes of the new element being created.

        Raises:
          ValueError: If the 'element_name' is not a valid child, or if an invalid
            attribute is specified in `kwargs`.

        Returns:
          An `mjcf.Element` corresponding to the newly created child element.
        """
        ...
    def insert(self, element_name, position, **kwargs):
        """Add a new child element to this element.

        Args:
          element_name: The tag of the element to add.
          position: Where to insert the new element.
          **kwargs: Attributes of the new element being created.

        Raises:
          ValueError: If the 'element_name' is not a valid child, or if an invalid
            attribute is specified in `kwargs`.

        Returns:
          An `mjcf.Element` corresponding to the newly created child element.
        """
        ...
    def __getattr__(self, name): ...
    def __setattr__(self, name, value): ...
    def __delattr__(self, name): ...
    def remove(self, affect_attachments=...):
        """Removes this element from the model."""
        ...
    @property
    def is_removed(self): ...
    def all_children(self): ...
    def to_xml(self, prefix_root=..., debug_context=..., *, precision=..., zero_threshold=...):
        """Generates an etree._Element corresponding to this MJCF element.

        Args:
          prefix_root: (optional) A `NameScope` object to be treated as root
            for the purpose of calculating the prefix.
            If `None` then no prefix is included.
          debug_context: (optional) A `debugging.DebugContext` object to which
            the debugging information associated with the generated XML is written.
            This is intended for internal use within PyMJCF; users should never need
            manually pass this argument.
          precision: (optional) Number of digits to output for floating point
            quantities.
          zero_threshold: (optional) When outputting XML, floating point quantities
            whose absolute value falls below this threshold will be treated as zero.

        Returns:
          An etree._Element object.
        """
        ...
    def to_xml_string(
        self, prefix_root=..., self_only=..., pretty_print=..., debug_context=..., *, precision=..., zero_threshold=...
    ):
        """Generates an XML string corresponding to this MJCF element.

        Args:
          prefix_root: (optional) A `NameScope` object to be treated as root
            for the purpose of calculating the prefix.
            If `None` then no prefix is included.
          self_only: (optional) A boolean, whether to generate an XML corresponding
            only to this element without any children.
          pretty_print: (optional) A boolean, whether to the XML string should be
            properly indented.
          debug_context: (optional) A `debugging.DebugContext` object to which
            the debugging information associated with the generated XML is written.
            This is intended for internal use within PyMJCF; users should never need
            manually pass this argument.
          precision: (optional) Number of digits to output for floating point
            quantities.
          zero_threshold: (optional) When outputting XML, floating point quantities
            whose absolute value falls below this threshold will be treated as zero.

        Returns:
          A string.
        """
        ...
    def __str__(self) -> str: ...
    def __repr__(self): ...
    def resolve_references(self): ...

class _AttachableElement(_ElementImpl):
    """Specialized object representing a <site> or <worldbody> element.

    This element defines a frame to which another MJCF model can be attached.
    """

    __slots__ = ...
    def attach(self, attachment):
        """Attaches another MJCF model at this site.

        An empty <body> will be created as an attachment frame. All children of
        `attachment`'s <worldbody> will be treated as children of this frame.
        Furthermore, all other elements in `attachment` are merged into the root
        of the MJCF model to which this element belongs.

        Args:
          attachment: An MJCF `RootElement`

        Returns:
          An `mjcf.Element` corresponding to the attachment frame. A joint can be
          added directly to this frame to give degrees of freedom to the attachment.

        Raises:
          ValueError: If `other` is not a valid attachment to this element.
        """
        ...

class _AttachmentFrame(_ElementImpl):
    """An specialized <body> representing a frame holding an external attachment."""

    __slots__ = ...
    def __init__(self, parent, site, attachment) -> None: ...
    def prefixed_identifier(self, prefix_root=...): ...
    def to_xml(self, prefix_root=..., debug_context=..., *, precision=..., zero_threshold=...): ...
    @property
    def full_identifier(self): ...

class _AttachmentFrameChild(_ElementImpl):
    """A child element of an attachment frame.

    Right now, this is always a <joint> or a <freejoint>. The name of the joint
    is not freely specifiable, but instead just inherits from the parent frame.
    This ensures uniqueness, as attachment frame identifiers always end in '/'.
    """

    __slots__ = ...
    def to_xml(self, prefix_root=..., debug_context=..., *, precision=..., zero_threshold=...): ...
    def prefixed_identifier(self, prefix_root=...): ...

class _DefaultElement(_ElementImpl):
    """Specialized object representing a <default> element.

    This is necessary for the proper handling of global defaults.
    """

    __slots__ = ...
    def all_children(self): ...
    def to_xml(self, prefix_root=..., debug_context=..., *, precision=..., zero_threshold=...): ...

class _ActuatorElement(_ElementImpl):
    """Specialized object representing an <actuator> element."""

    __slots__ = ...

class RootElement(_ElementImpl):
    """The root `<mujoco>` element of an MJCF model."""

    __slots__ = ...
    def __init__(self, model=..., model_dir=..., assets=...) -> None: ...
    @property
    def namescope(self): ...
    @property
    def root(self): ...
    @property
    def model(self): ...
    @model.setter
    def model(self, new_name): ...
    def attach(self, other): ...
    def detach(self): ...
    def include_copy(self, other, override_attributes=...): ...
    @property
    def parent_model(self):
        """The RootElement of the MJCF model to which this one is attached."""
        ...
    @property
    def root_model(self): ...
    def get_assets(self):
        """Returns a dict containing the binary assets referenced in this model.

        This will contain `{vfs_filename: contents}` pairs. `vfs_filename` will be
        the name of the asset in MuJoCo's Virtual File System, which corresponds to
        the filename given in the XML returned by `to_xml_string()`. `contents` is a
        bytestring.

        This dict can be used together with the result of `to_xml_string()` to
        construct a `mujoco.Physics` instance:

        ```python
        physics = mujoco.Physics.from_xml_string(
            xml_string=mjcf_model.to_xml_string(),
            assets=mjcf_model.get_assets())
        ```
        """
        ...
    @property
    def full_identifier(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, _): ...
    def is_same_as(self, other): ...

class _ElementListView:
    """A hybrid list/dict-like view to a group of repeated MJCF elements."""

    def __init__(self, spec, parent) -> None: ...
    @property
    def spec(self): ...
    @property
    def tag(self): ...
    @property
    def namescope(self): ...
    @property
    def parent(self): ...
    def __len__(self): ...
    def __iter__(self): ...
    def clear(self): ...
    def __getitem__(self, index): ...
    def __delitem__(self, index): ...
    def __str__(self) -> str: ...
    def __repr__(self): ...

"""
This type stub file was generated by pyright.
"""

from .. import caching, parent, units
from ..typed import Dict, List, NDArray, Optional, float64
from .entities import Entity

"""
path.py
-----------

A module designed to work with vector paths such as
those stored in a DXF or SVG file.
"""

class Path(parent.Geometry):
    """
    A Path object consists of vertices and entities. Vertices
    are a simple (n, dimension) float array of points in space.

    Entities are a list of objects representing geometric
    primitives, such as Lines, Arcs, BSpline, etc. All entities
    reference vertices by index, so any transform applied to the
    simple vertex array is applied to the entity.
    """

    def __init__(
        self,
        entities: Optional[List[Entity]] = ...,
        vertices: Optional[NDArray[float64]] = ...,
        metadata: Optional[Dict] = ...,
        process: bool = ...,
        colors=...,
        **kwargs,
    ) -> None:
        """
        Instantiate a path object.

        Parameters
        -----------
        entities : (m,) trimesh.path.entities.Entity
          Contains geometric entities
        vertices : (n, dimension) float
          The vertices referenced by entities
        metadata : dict
          Any metadata about the path
        process :  bool
          Run simple cleanup or not
        """
        ...
    def __repr__(self):  # -> str:
        """
        Print a quick summary of the number of vertices and entities.
        """
        ...
    def process(self):  # -> Self@Path:
        """
        Apply basic cleaning functions to the Path object in-place.
        """
        ...
    @property
    def colors(self):  # -> NDArray[uint8] | None:
        """
        Colors are stored per-entity.

        Returns
        ------------
        colors : (len(entities), 4) uint8
          RGBA colors for each entity
        """
        ...
    @colors.setter
    def colors(self, values):  # -> None:
        """
        Set the color for every entity in the Path.

        Parameters
        ------------
        values : (len(entities), 4) uint8
          Color of each entity
        """
        ...
    @property
    def vertices(self):  # -> TrackedArray:
        ...
    @vertices.setter
    def vertices(self, values: NDArray[float64]):  # -> None:
        ...
    @property
    def entities(self):  # -> NDArray[Any] | NDArray[Unknown]:
        """
        The actual entities making up the path.

        Returns
        -----------
        entities : (n,) trimesh.path.entities.Entity
          Entities such as Line, Arc, or BSpline curves
        """
        ...
    @entities.setter
    def entities(self, values):  # -> None:
        ...
    @property
    def layers(self):  # -> list[Any | Unknown]:
        """
        Get a list of the layer for every entity.

        Returns
        ---------
        layers : (len(entities), ) any
          Whatever is stored in each `entity.layer`
        """
        ...
    def __hash__(self) -> int:
        """
        A hash of the current vertices and entities.

        Returns
        ------------
        hash : long int
          Appended hashes
        """
        ...
    @caching.cache_decorator
    def paths(self):  # -> Any:
        """
        Sequence of closed paths, encoded by entity index.

        Returns
        ---------
        paths : (n,) sequence of (*,) int
          Referencing self.entities
        """
        ...
    @caching.cache_decorator
    def dangling(self):  # -> NDArray[signedinteger[Any]]:
        """
        List of entities that aren't included in a closed path

        Returns
        ----------
        dangling : (n,) int
          Index of self.entities
        """
        ...
    @caching.cache_decorator
    def kdtree(self):  # -> cKDTree[None]:
        """
        A KDTree object holding the vertices of the path.

        Returns
        ----------
        kdtree : scipy.spatial.cKDTree
          Object holding self.vertices
        """
        ...
    @property
    def scale(self):  # -> floating[Any]:
        """
        What is a representitive number that reflects the magnitude
        of the world holding the paths, for numerical comparisons.

        Returns
        ----------
        scale : float
          Approximate size of the world holding this path
        """
        ...
    @caching.cache_decorator
    def length(self):  # -> float:
        """
        The total discretized length of every entity.

        Returns
        --------
        length : float
          Summed length of every entity
        """
        ...
    @caching.cache_decorator
    def bounds(self):  # -> NDArray[float64]:
        """
        Return the axis aligned bounding box of the current path.

        Returns
        ----------
        bounds : (2, dimension) float
          AABB with (min, max) coordinates
        """
        ...
    @caching.cache_decorator
    def centroid(self):  # -> Any:
        """
        Return the centroid of axis aligned bounding box enclosing
        all entities of the path object.

        Returns
        -----------
        centroid : (d,) float
          Approximate centroid of the path
        """
        ...
    @property
    def extents(self):  # -> Any:
        """
        The size of the axis aligned bounding box.

        Returns
        ---------
        extents : (dimension,) float
          Edge length of AABB
        """
        ...
    @property
    def units(self):  # -> None:
        """
        If there are units defined in self.metadata return them.

        Returns
        -----------
        units : str
          Current unit system
        """
        ...
    @units.setter
    def units(self, units):  # -> None:
        ...
    def convert_units(self, desired, guess=...):  # -> None:
        """
        Convert the units of the current drawing in place.

        Parameters
        -----------
        desired : str
          Unit system to convert to
        guess : bool
          If True will attempt to guess units
        """
        ...
    def explode(self):  # -> None:
        """
        Turn every multi- segment entity into single segment
        entities in- place.
        """
        ...
    def fill_gaps(self, distance=...):  # -> None:
        """
        Find vertices without degree 2 and try to connect to
        other vertices. Operations are done in-place.

        Parameters
        ----------
        distance : float
          Connect vertices up to this distance
        """
        ...
    @property
    def is_closed(self):  # -> bool:
        """
        Are all entities connected to other entities.

        Returns
        -----------
        closed : bool
          Every entity is connected at its ends
        """
        ...
    @property
    def is_empty(self):  # -> bool:
        """
        Are any entities defined for the current path.

        Returns
        ----------
        empty : bool
          True if no entities are defined
        """
        ...
    @caching.cache_decorator
    def vertex_graph(self):  # -> Graph | None:
        """
        Return a networkx.Graph object for the entity connectivity

        graph : networkx.Graph
          Holds vertex indexes
        """
        ...
    @caching.cache_decorator
    def vertex_nodes(self):  # -> NDArray[Any | Unknown]:
        """
        Get a list of which vertex indices are nodes,
        which are either endpoints or points where the
        entity makes a direction change.

        Returns
        --------------
        nodes : (n, 2) int
          Indexes of self.vertices which are nodes
        """
        ...
    def apply_transform(self, transform):  # -> Self@Path:
        """
        Apply a transformation matrix to the current path in- place

        Parameters
        -----------
        transform : (d+1, d+1) float
          Homogeneous transformations for vertices
        """
        ...
    def apply_layer(self, name):  # -> None:
        """
        Apply a layer name to every entity in the path.

        Parameters
        ------------
        name : str
          Apply layer name to every entity
        """
        ...
    def rezero(self):  # -> NDArray[float64]:
        """
        Translate so that every vertex is positive in the current
        mesh is positive.

        Returns
        -----------
        matrix : (dimension + 1, dimension + 1) float
          Homogeneous transformations that was applied
          to the current Path object.
        """
        ...
    def merge_vertices(self, digits=...):  # -> None:
        """
        Merges vertices which are identical and replace references
        by altering `self.entities` and `self.vertices`

        Parameters
        --------------
        digits : None, or int
          How many digits to consider when merging vertices
        """
        ...
    def replace_vertex_references(self, mask):  # -> None:
        """
        Replace the vertex index references in every entity.

        Parameters
        ------------
        mask : (len(self.vertices), ) int
          Contains new vertex indexes

        Notes
        ------------
        entity.points in self.entities
          Replaced by mask[entity.points]
        """
        ...
    def remove_entities(self, entity_ids):  # -> None:
        """
        Remove entities by index.

        Parameters
        -----------
        entity_ids : (n,) int
          Indexes of self.entities to remove
        """
        ...
    def remove_invalid(self):  # -> None:
        """
        Remove entities which declare themselves invalid

        Notes
        ----------
        self.entities: shortened
        """
        ...
    def remove_duplicate_entities(self):  # -> None:
        """
        Remove entities that are duplicated

        Notes
        -------
        self.entities: length same or shorter
        """
        ...
    @caching.cache_decorator
    def referenced_vertices(self):  # -> NDArray[int64]:
        """
        Which vertices are referenced by an entity.

        Returns
        -----------
        referenced_vertices: (n,) int, indexes of self.vertices
        """
        ...
    def remove_unreferenced_vertices(self):  # -> None:
        """
        Removes all vertices which aren't used by an entity.

        Notes
        ---------
        self.vertices : reordered and shortened
        self.entities : entity.points references updated
        """
        ...
    @caching.cache_decorator
    def discrete(self) -> List[NDArray[float64]]:
        """
        A sequence of connected vertices in space, corresponding to
        self.paths.

        Returns
        ---------
        discrete : (len(self.paths),)
            A sequence of (m*, dimension) float
        """
        ...
    def export(self, file_obj=..., file_type=..., **kwargs):
        """
        Export the path to a file object or return data.

        Parameters
        ---------------
        file_obj : None, str, or file object
          File object or string to export to
        file_type : None or str
          Type of file: dxf, dict, svg

        Returns
        ---------------
        exported : bytes or str
          Exported as specified type
        """
        ...
    def to_dict(self): ...
    def copy(self):  # -> Self@Path:
        """
        Get a copy of the current mesh

        Returns
        ---------
        copied : Path object
          Copy of self
        """
        ...
    def scene(self):  # -> Scene:
        """
        Get a scene object containing the current Path3D object.

        Returns
        --------
        scene: trimesh.scene.Scene object containing current path
        """
        ...
    def __add__(self, other):  # -> Any:
        """
        Concatenate two Path objects by appending vertices and
        reindexing point references.

        Parameters
        -----------
        other: Path object

        Returns
        -----------
        concat: Path object, appended from self and other
        """
        ...

class Path3D(Path):
    """
    Hold multiple vector curves (lines, arcs, splines, etc) in 3D.
    """

    def to_planar(
        self, to_2D=..., normal=..., check=...
    ):  # -> tuple[Path2D, NDArray[float64]] | tuple[Path2D, Any | NDArray[floating[Any]]]:
        """
        Check to see if current vectors are all coplanar.

        If they are, return a Path2D and a transform which will
        transform the 2D representation back into 3 dimensions

        Parameters
        -----------
        to_2D: (4,4) float
            Homogeneous transformation matrix to apply,
            If not passed a plane will be fitted to vertices.
        normal: (3,) float, or None
           Approximate normal of direction of plane
           If to_2D is not specified sign
           will be applied to fit plane normal
        check:  bool
            If True: Raise a ValueError if
            points aren't coplanar

        Returns
        -----------
        planar : trimesh.path.Path2D
                   Current path transformed onto plane
        to_3D :  (4,4) float
                   Homeogenous transformations to move planar
                   back into 3D space
        """
        ...
    def show(self, **kwargs):  # -> SceneViewer:
        """
        Show the current Path3D object.
        """
        ...

class Path2D(Path):
    """
    Hold multiple vector curves (lines, arcs, splines, etc) in 3D.
    """

    def show(self, annotations=...):  # -> None:
        """
        Plot the current Path2D object using matplotlib.
        """
        ...
    def apply_obb(self):  # -> Any:
        """
        Transform the current path so that its OBB is axis aligned
        and OBB center is at the origin.

        Returns
        -----------
        obb : (3, 3) float
          Homogeneous transformation matrix
        """
        ...
    def apply_scale(self, scale):  # -> Self@Path2D:
        """
        Apply a 2D scale to the current Path2D.

        Parameters
        -------------
        scale : float or (2,) float
          Scale to apply in-place.
        """
        ...
    @caching.cache_decorator
    def obb(self):  # -> Any | NDArray[float64]:
        """
        Get a transform that centers and aligns the OBB of the
        referenced vertices with the XY axis.

        Returns
        -----------
        obb : (3, 3) float
          Homogeneous transformation matrix
        """
        ...
    def rasterize(self, pitch=..., origin=..., resolution=..., fill=..., width=..., **kwargs):  # -> Image | None:
        """
        Rasterize a Path2D object into a boolean image ("mode 1").

        Parameters
        ------------
        pitch : float or (2,) float
          Length(s) in model space of pixel edges
        origin : (2,) float
          Origin position in model space
        resolution : (2,) int
          Resolution in pixel space
        fill : bool
          If True will return closed regions as filled
        width : int
          If not None will draw outline this wide (pixels)

        Returns
        ------------
        raster : PIL.Image object, mode 1
          Rasterized version of closed regions.
        """
        ...
    def sample(self, count, **kwargs):  # -> NDArray[Any] | Any | None:
        """
        Use rejection sampling to generate random points inside a
        polygon.

        Parameters
        -----------
        count : int
          Number of points to return
          If there are multiple bodies, there will
          be up to count * bodies points returned
        factor : float
          How many points to test per loop
          IE, count * factor
        max_iter : int,
          Maximum number of intersection loops
          to run, total points sampled is
          count * factor * max_iter

        Returns
        -----------
        hit : (n, 2) float
          Random points inside polygon
        """
        ...
    @property
    def body_count(self):  # -> int:
        """
        Returns a count of the number of unconnected polygons that
        may contain other curves but aren't contained themselves.

        Returns
        ---------
        body_count : int
          Number of unconnected independent polygons.
        """
        ...
    def to_3D(self, transform=...):  # -> Path3D:
        """
        Convert 2D path to 3D path on the XY plane.

        Parameters
        -------------
        transform : (4, 4) float
          If passed, will transform vertices.
          If not passed and 'to_3D' is in self.metadata
          that transform will be used.

        Returns
        -----------
        path_3D : Path3D
          3D version of current path
        """
        ...
    @caching.cache_decorator
    def polygons_closed(self):  # -> NDArray[Any] | None:
        """
        Cycles in the vertex graph, as shapely.geometry.Polygons.
        These are polygon objects for every closed circuit, with no notion
        of whether a polygon is a hole or an area. Every polygon in this
        list will have an exterior, but NO interiors.

        Returns
        ---------
        polygons_closed: (n,) list of shapely.geometry.Polygon objects
        """
        ...
    @caching.cache_decorator
    def polygons_full(self):  # -> list[None]:
        """
        A list of shapely.geometry.Polygon objects with interiors created
        by checking which closed polygons enclose which other polygons.

        Returns
        ---------
        full : (len(self.root),) shapely.geometry.Polygon
            Polygons containing interiors
        """
        ...
    @caching.cache_decorator
    def area(self):  # -> float:
        """
        Return the area of the polygons interior.

        Returns
        ---------
        area : float
          Total area of polygons minus interiors
        """
        ...
    def extrude(self, height, **kwargs):  # -> Extrusion | list[Extrusion]:
        """
        Extrude the current 2D path into a 3D mesh.

        Parameters
        ----------
        height: float, how far to extrude the profile
        kwargs: passed directly to meshpy.triangle.build:
                triangle.build(mesh_info,
                               verbose=False,
                               refinement_func=None,
                               attributes=False,
                               volume_constraints=True,
                               max_volume=None,
                               allow_boundary_steiner=True,
                               allow_volume_steiner=True,
                               quality_meshing=True,
                               generate_edges=None,
                               generate_faces=False,
                               min_angle=None)
        Returns
        --------
        mesh: trimesh object representing extruded polygon
        """
        ...
    def triangulate(
        self, **kwargs
    ):  # -> tuple[Unknown | NDArray[Any] | NDArray[Unknown], Unknown | NDArray[Any] | NDArray[Unknown]]:
        """
        Create a region- aware triangulation of the 2D path.

        Parameters
        -------------
        **kwargs : dict
          Passed to `trimesh.creation.triangulate_polygon`

        Returns
        -------------
        vertices : (n, 2) float
          2D vertices of triangulation
        faces : (n, 3) int
          Indexes of vertices for triangles
        """
        ...
    def medial_axis(self, resolution=..., clip=...):  # -> Path2D | Any:
        """
        Find the approximate medial axis based
        on a voronoi diagram of evenly spaced points on the
        boundary of the polygon.

        Parameters
        ----------
        resolution : None or float
          Distance between each sample on the polygon boundary
        clip : None, or (2,) float
          Min, max number of samples

        Returns
        ----------
        medial : Path2D object
          Contains only medial axis of Path
        """
        ...
    def connected_paths(self, path_id, include_self=...):  # -> NDArray[signedinteger[Any]]:
        """
        Given an index of self.paths find other paths which
        overlap with that path.

        Parameters
        -----------
        path_id : int
          Index of self.paths
        include_self : bool
          Should the result include path_id or not

        Returns
        -----------
        path_ids :  (n, ) int
          Indexes of self.paths that overlap input path_id
        """
        ...
    def simplify(self, **kwargs):  # -> Self@Path2D:
        """
        Return a version of the current path with colinear segments
        merged, and circles entities replacing segmented circular paths.

        Returns
        ---------
        simplified : Path2D object
        """
        ...
    def simplify_spline(self, smooth=..., verbose=...):  # -> Any:
        """
        Convert paths into b-splines.

        Parameters
        -----------
        smooth : float
          How much the spline should smooth the curve
        verbose : bool
          Print detailed log messages

        Returns
        ------------
        simplified : Path2D
          Discrete curves replaced with splines
        """
        ...
    def split(self, **kwargs):  # -> NDArray[Unknown]:
        """
        If the current Path2D consists of n 'root' curves,
        split them into a list of n Path2D objects

        Returns
        ----------
        split:  (n,) list of Path2D objects
          Each connected region and interiors
        """
        ...
    def plot_discrete(self, show=..., annotations=...):  # -> Axes:
        """
        Plot the closed curves of the path.
        """
        ...
    def plot_entities(self, show=..., annotations=..., color=...):  # -> None:
        """
        Plot the entities of the path with no notion of topology.

        Parameters
        ------------
        show : bool
          Open a window immediately or not
        annotations : bool
          Call an entities custom plot function.
        color : str
          Override entity colors and make them all this color.
        """
        ...
    @property
    def identifier(self):  # -> NDArray[float64] | None:
        """
        A unique identifier for the path.

        Returns
        ---------
        identifier : (5,) float
          Unique identifier
        """
        ...
    @caching.cache_decorator
    def identifier_hash(self):  # -> str:
        """
        Return a hash of the identifier.

        Returns
        ----------
        hashed : (64,) str
          SHA256 hash of the identifier vector.
        """
        ...
    @property
    def path_valid(self):  # -> NDArray[Any]:
        """
        Returns
        ----------
        path_valid : (n,) bool
          Indexes of self.paths self.polygons_closed
          which are valid polygons.
        """
        ...
    @caching.cache_decorator
    def root(self):  # -> None:
        """
        Which indexes of self.paths/self.polygons_closed
        are root curves, also known as 'shell' or 'exterior.

        Returns
        ---------
        root : (n,) int
          List of indexes
        """
        ...
    @caching.cache_decorator
    def enclosure(self):  # -> Any:
        """
        Undirected graph object of polygon enclosure.

        Returns
        -----------
        enclosure : networkx.Graph
          Enclosure graph of self.polygons by index.
        """
        ...
    @caching.cache_decorator
    def enclosure_directed(self):  # -> DiGraph | None:
        """
        Directed graph of polygon enclosure.

        Returns
        ----------
        enclosure_directed : networkx.DiGraph
          Directed graph: child nodes are fully
          contained by their parent node.
        """
        ...
    @caching.cache_decorator
    def enclosure_shell(self):  # -> OrderedDict[Any, NDArray[signedinteger[Any]]]:
        """
        A dictionary of path indexes which are 'shell' paths, and values
        of 'hole' paths.

        Returns
        ----------
        corresponding : dict
          {index of self.paths of shell : [indexes of holes]}
        """
        ...

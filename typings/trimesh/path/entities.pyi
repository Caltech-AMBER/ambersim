"""
This type stub file was generated by pyright.
"""

from ..util import ABC

"""
entities.py
--------------

Basic geometric primitives which only store references to
vertex indices rather than vertices themselves.
"""

class Entity(ABC):
    def __init__(self, points, closed=..., layer=..., metadata=..., color=..., **kwargs) -> None: ...
    @property
    def metadata(self):  # -> dict[Unknown, Unknown]:
        """
        Get any metadata about the entity.

        Returns
        ---------
        metadata : dict
          Bag of properties.
        """
        ...
    @property
    def layer(self):  # -> None:
        """
        Set the layer the entity resides on as a shortcut
        to putting it in the entity metadata.

        Returns
        ----------
        layer : any
          Hashable layer identifier.
        """
        ...
    @layer.setter
    def layer(self, value):  # -> None:
        """
        Set the current layer of the entity.

        Returns
        ----------
        layer : any
          Hashable layer indicator
        """
        ...
    def to_dict(self):  # -> dict[str, Unknown]:
        """
        Returns a dictionary with all of the information
        about the entity.

        Returns
        -----------
        as_dict : dict
          Has keys 'type', 'points', 'closed'
        """
        ...
    @property
    def closed(self):  # -> Any | Literal[False]:
        """
        If the first point is the same as the end point
        the entity is closed

        Returns
        -----------
        closed : bool
          Is the entity closed or not?
        """
        ...
    @property
    def nodes(self):  # -> ndarray[Any, dtype[int64]]:
        """
        Returns an (n,2) list of nodes, or vertices on the path.
        Note that this generic class function assumes that all of the
        reference points are on the path which is true for lines and
        three point arcs.

        If you were to define another class where that wasn't the case
        (for example, the control points of a bezier curve),
        you would need to implement an entity- specific version of this
        function.

        The purpose of having a list of nodes is so that they can then be
        added as edges to a graph so we can use functions to check
        connectivity, extract paths, etc.

        The slicing on this function is essentially just tiling points
        so the first and last vertices aren't repeated. Example:

        self.points = [0,1,2]
        returns:      [[0,1], [1,2]]
        """
        ...
    @property
    def end_points(self):
        """
        Returns the first and last points. Also note that if you
        define a new entity class where the first and last vertices
        in self.points aren't the endpoints of the curve you need to
        implement this function for your class.

        Returns
        -------------
        ends : (2,) int
          Indices of the two end points of the entity
        """
        ...
    @property
    def is_valid(self):  # -> Literal[True]:
        """
        Is the current entity valid.

        Returns
        -----------
        valid : bool
          Is the current entity well formed
        """
        ...
    def reverse(self, direction=...):  # -> None:
        """
        Reverse the current entity in place.

        Parameters
        ----------------
        direction : int
          If positive will not touch direction
          If negative will reverse self.points
        """
        ...
    def bounds(self, vertices):  # -> NDArray[Unknown]:
        """
        Return the AABB of the current entity.

        Parameters
        -----------
        vertices : (n, dimension) float
          Vertices in space

        Returns
        -----------
        bounds : (2, dimension) float
          Coordinates of AABB, in (min, max) form
        """
        ...
    def length(self, vertices):  # -> Any:
        """
        Return the total length of the entity.

        Parameters
        --------------
        vertices : (n, dimension) float
          Vertices in space

        Returns
        ---------
        length : float
          Total length of entity
        """
        ...
    def explode(self):  # -> list[Self@Entity]:
        """
        Split the entity into multiple entities.

        Returns
        ------------
        explode : list of Entity
          Current entity split into multiple entities.
        """
        ...
    def copy(self):  # -> Self@Entity:
        """
        Return a copy of the current entity.

        Returns
        ------------
        copied : Entity
          Copy of current entity
        """
        ...
    def __hash__(self) -> int:
        """
        Return a hash that represents the current entity.

        Returns
        ----------
        hashed : int
            Hash of current class name, points, and closed
        """
        ...

class Text(Entity):
    """
    Text to annotate a 2D or 3D path.
    """

    def __init__(
        self, origin, text, height=..., vector=..., normal=..., align=..., layer=..., color=..., metadata=...
    ) -> None:
        """
        An entity for text labels.

        Parameters
        --------------
        origin : int
          Index of a single vertex for text origin
        text : str
          The text to label
        height : float or None
          The height of text
        vector : int or None
          An vertex index for which direction text
          is written along unitized: vector - origin
        normal : int or None
          A vertex index for the plane normal:
          vector is along unitized: normal - origin
        align : (2,) str or None
          Where to draw from for [horizontal, vertical]:
              'center', 'left', 'right'
        """
        ...
    @property
    def origin(self):  # -> Any:
        """
        The origin point of the text.

        Returns
        -----------
        origin : int
          Index of vertices
        """
        ...
    @origin.setter
    def origin(self, value):  # -> None:
        ...
    @property
    def vector(self):  # -> Any:
        """
        A point representing the text direction
        along the vector: vertices[vector] - vertices[origin]

        Returns
        ----------
        vector : int
          Index of vertex
        """
        ...
    @vector.setter
    def vector(self, value):  # -> None:
        ...
    @property
    def normal(self):  # -> Any:
        """
        A point representing the plane normal along the
        vector: vertices[normal] - vertices[origin]

        Returns
        ------------
        normal : int
          Index of vertex
        """
        ...
    @normal.setter
    def normal(self, value):  # -> None:
        ...
    def plot(self, vertices, show=...):  # -> None:
        """
        Plot the text using matplotlib.

        Parameters
        --------------
        vertices : (n, 2) float
          Vertices in space
        show : bool
          If True, call plt.show()
        """
        ...
    def angle(self, vertices):  # -> Any:
        """
        If Text is 2D, get the rotation angle in radians.

        Parameters
        -----------
        vertices : (n, 2) float
          Vertices in space referenced by self.points

        Returns
        ---------
        angle : float
          Rotation angle in radians
        """
        ...
    def length(self, vertices):  # -> float:
        ...
    def discrete(self, *args, **kwargs):  # -> NDArray[Any]:
        ...
    @property
    def closed(self):  # -> Literal[False]:
        ...
    @property
    def is_valid(self):  # -> Literal[True]:
        ...
    @property
    def nodes(self):  # -> NDArray[Any]:
        ...
    @property
    def end_points(self):  # -> NDArray[Any]:
        ...

class Line(Entity):
    """
    A line or poly-line entity
    """

    def discrete(self, vertices, scale=...):
        """
        Discretize into a world- space path.

        Parameters
        ------------
        vertices: (n, dimension) float
          Points in space
        scale : float
          Size of overall scene for numerical comparisons

        Returns
        -------------
        discrete: (m, dimension) float
          Path in space composed of line segments
        """
        ...
    @property
    def is_valid(self):  # -> bool_:
        """
        Is the current entity valid.

        Returns
        -----------
        valid : bool
          Is the current entity well formed
        """
        ...
    def explode(self):  # -> list[Line]:
        """
        If the current Line entity consists of multiple line
        break it up into n Line entities.

        Returns
        ----------
        exploded: (n,) Line entities
        """
        ...

class Arc(Entity):
    @property
    def closed(self):  # -> Any | bool:
        """
        A boolean flag for whether the arc is closed (a circle) or not.

        Returns
        ----------
        closed : bool
          If set True, Arc will be a closed circle
        """
        ...
    @closed.setter
    def closed(self, value):  # -> None:
        """
        Set the Arc to be closed or not, without
        changing the control points

        Parameters
        ------------
        value : bool
          Should this Arc be a closed circle or not
        """
        ...
    @property
    def is_valid(self):  # -> bool:
        """
        Is the current Arc entity valid.

        Returns
        -----------
        valid : bool
          Does the current Arc have exactly 3 control points
        """
        ...
    def length(self, vertices):  # -> float:
        """
        Return the arc length of the 3-point arc.

        Parameter
        ----------
        vertices : (n, d) float
          Vertices for overall drawing.

        Returns
        -----------
        length : float
          Length of arc.
        """
        ...
    def discrete(self, vertices, scale=...):  # -> ndarray[Any, dtype[float64]] | Any:
        """
        Discretize the arc entity into line sections.

        Parameters
        ------------
        vertices : (n, dimension) float
            Points in space
        scale : float
            Size of overall scene for numerical comparisons

        Returns
        -------------
        discrete : (m, dimension) float
          Path in space made up of line segments
        """
        ...
    def center(self, vertices, **kwargs):  # -> ArcInfo:
        """
        Return the center information about the arc entity.

        Parameters
        -------------
        vertices : (n, dimension) float
          Vertices in space

        Returns
        -------------
        info : dict
          With keys: 'radius', 'center'
        """
        ...
    def bounds(self, vertices):  # -> NDArray[float64]:
        """
        Return the AABB of the arc entity.

        Parameters
        -----------
        vertices: (n, dimension) float
          Vertices in space

        Returns
        -----------
        bounds : (2, dimension) float
          Coordinates of AABB in (min, max) form
        """
        ...

class Curve(Entity):
    """
    The parent class for all wild curves in space.
    """

    @property
    def nodes(self):  # -> list[list[Any]]:
        ...

class Bezier(Curve):
    """
    An open or closed Bezier curve
    """

    def discrete(self, vertices, scale=..., count=...):  # -> Any:
        """
        Discretize the Bezier curve.

        Parameters
        -------------
        vertices : (n, 2) or (n, 3) float
          Points in space
        scale : float
          Scale of overall drawings (for precision)
        count : int
          Number of segments to return

        Returns
        -------------
        discrete : (m, 2) or (m, 3) float
          Curve as line segments
        """
        ...

class BSpline(Curve):
    """
    An open or closed B- Spline.
    """

    def __init__(self, points, knots, layer=..., metadata=..., color=..., **kwargs) -> None: ...
    def discrete(self, vertices, count=..., scale=...):
        """
        Discretize the B-Spline curve.

        Parameters
        -------------
        vertices : (n, 2) or (n, 3) float
          Points in space
        scale : float
          Scale of overall drawings (for precision)
        count : int
          Number of segments to return

        Returns
        -------------
        discrete : (m, 2) or (m, 3) float
          Curve as line segments
        """
        ...
    def to_dict(self):  # -> dict[str, Unknown]:
        """
        Returns a dictionary with all of the information
        about the entity.
        """
        ...

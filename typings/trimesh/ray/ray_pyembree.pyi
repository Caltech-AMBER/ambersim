"""
This type stub file was generated by pyright.
"""

import numpy as np

from ..constants import log_time

"""
Ray queries using the embreex package with the
API wrapped to match our native raytracer.
"""
_ray_offset_factor = ...
_ray_offset_floor = ...
_embree_dtype = np.float32

class RayMeshIntersector:
    def __init__(self, geometry, scale_to_box=...) -> None:
        """
        Do ray- mesh queries.

        Parameters
        -------------
        geometry : Trimesh object
          Mesh to do ray tests on
        scale_to_box : bool
          If true, will scale mesh to approximate
          unit cube to avoid problems with extreme
          large or small meshes.
        """
        ...
    def intersects_location(
        self, ray_origins, ray_directions, multiple_hits=...
    ):  # -> tuple[NDArray[Any] | NDArray[Unknown], NDArray[Unknown], NDArray[Unknown]]:
        """
        Return the location of where a ray hits a surface.

        Parameters
        ----------
        ray_origins : (n, 3) float
          Origins of rays
        ray_directions : (n, 3) float
          Direction (vector) of rays

        Returns
        ---------
        locations : (m) sequence of (p, 3) float
          Intersection points
        index_ray : (m,) int
          Indexes of ray
        index_tri : (m,) int
          Indexes of mesh.faces
        """
        ...
    @log_time
    def intersects_id(
        self, ray_origins, ray_directions, multiple_hits=..., max_hits=..., return_locations=...
    ):  # -> tuple[NDArray[Unknown], NDArray[Unknown], NDArray[Any] | NDArray[Unknown]] | tuple[NDArray[Unknown], NDArray[Unknown]]:
        """
        Find the triangles hit by a list of rays, including
        optionally multiple hits along a single ray.


        Parameters
        ----------
        ray_origins : (n, 3) float
          Origins of rays
        ray_directions : (n, 3) float
          Direction (vector) of rays
        multiple_hits : bool
          If True will return every hit along the ray
          If False will only return first hit
        max_hits : int
          Maximum number of hits per ray
        return_locations : bool
          Should we return hit locations or not

        Returns
        ---------
        index_tri : (m,) int
          Indexes of mesh.faces
        index_ray : (m,) int
          Indexes of ray
        locations : (m) sequence of (p, 3) float
          Intersection points, only returned if return_locations
        """
        ...
    @log_time
    def intersects_first(self, ray_origins, ray_directions):  # -> Any:
        """
        Find the index of the first triangle a ray hits.


        Parameters
        ----------
        ray_origins : (n, 3) float
          Origins of rays
        ray_directions : (n, 3) float
          Direction (vector) of rays

        Returns
        ----------
        triangle_index : (n,) int
          Index of triangle ray hit, or -1 if not hit
        """
        ...
    def intersects_any(self, ray_origins, ray_directions):  # -> Any:
        """
        Check if a list of rays hits the surface.


        Parameters
        -----------
        ray_origins : (n, 3) float
          Origins of rays
        ray_directions : (n, 3) float
          Direction (vector) of rays

        Returns
        ----------
        hit : (n,) bool
          Did each ray hit the surface
        """
        ...
    def contains_points(self, points):  # -> NDArray[Any]:
        """
        Check if a mesh contains a list of points, using ray tests.

        If the point is on the surface of the mesh, behavior is undefined.

        Parameters
        ---------
        points: (n, 3) points in space

        Returns
        ---------
        contains: (n,) bool
                         Whether point is inside mesh or not
        """
        ...

class _EmbreeWrap:
    """
    A light wrapper for Embreex scene objects which
    allows queries to be scaled to help with precision
    issues, as well as selecting the correct dtypes.
    """

    def __init__(self, vertices, faces, scale) -> None: ...
    def run(self, origins, normals, **kwargs): ...

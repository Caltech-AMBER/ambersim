"""
This type stub file was generated by pyright.
"""

"""
A basic slow implementation of ray- triangle queries.
"""

class RayMeshIntersector:
    """
    An object to query a mesh for ray intersections.
    Precomputes an r-tree for each triangle on the mesh.
    """

    def __init__(self, mesh) -> None: ...
    def intersects_id(
        self, ray_origins, ray_directions, return_locations=..., multiple_hits=..., **kwargs
    ):  # -> tuple[NDArray[int64], NDArray[int64], NDArray[float64] | Any] | tuple[NDArray[int64], NDArray[int64]]:
        """
        Find the intersections between the current mesh and an
        array of rays.

        Parameters
        ------------
        ray_origins :  (m, 3) float
          Ray origin points
        ray_directions : (m, 3) float
          Ray direction vectors
        multiple_hits :  bool
          Consider multiple hits of each ray or not
        return_locations : bool
          Return hit locations or not

        Returns
        -----------
        index_triangle : (h,) int
          Index of triangles hit
        index_ray : (h,) int
          Index of ray that hit triangle
        locations : (h, 3) float
          [optional] Position of intersection in space
        """
        ...
    def intersects_location(
        self, ray_origins, ray_directions, **kwargs
    ):  # -> tuple[NDArray[float64] | Any, NDArray[int64], NDArray[int64]]:
        """
        Return unique cartesian locations where rays hit the mesh.
        If you are counting the number of hits a ray had, this method
        should be used as if only the triangle index is used on- edge hits
        will be counted twice.

        Parameters
        ------------
        ray_origins : (m, 3) float
          Ray origin points
        ray_directions : (m, 3) float
          Ray direction vectors

        Returns
        ---------
        locations : (n) sequence of (m,3) float
          Intersection points
        index_ray : (n,) int
          Array of ray indexes
        index_tri: (n,) int
          Array of triangle (face) indexes
        """
        ...
    def intersects_first(self, ray_origins, ray_directions, **kwargs):  # -> NDArray[signedinteger[Any]]:
        """
        Find the index of the first triangle a ray hits.


        Parameters
        ----------
        ray_origins : (n, 3) float
          Origins of rays
        ray_directions : (n, 3) float
          Direction (vector) of rays

        Returns
        ----------
        triangle_index : (n,) int
          Index of triangle ray hit, or -1 if not hit
        """
        ...
    def intersects_any(self, ray_origins, ray_directions, **kwargs):  # -> NDArray[Any]:
        """
        Find out if each ray hit any triangle on the mesh.

        Parameters
        ------------
        ray_origins : (m, 3) float
          Ray origin points
        ray_directions : (m, 3) float
          Ray direction vectors

        Returns
        ---------
        hit : (m,) bool
          Whether any ray hit any triangle on the mesh
        """
        ...
    def contains_points(self, points):  # -> NDArray[Any]:
        """
        Check if a mesh contains a list of points, using ray tests.

        If the point is on the surface of the mesh the behavior
        is undefined.

        Parameters
        ------------
        points : (n, 3) float
          Points in space

        Returns
        ---------
        contains : (n,) bool
          Whether point is inside mesh or not
        """
        ...

def ray_triangle_id(
    triangles, ray_origins, ray_directions, triangles_normal=..., tree=..., multiple_hits=...
):  # -> tuple[NDArray[int64], NDArray[int64], NDArray[float64]] | tuple[ndarray[Any, dtype[int64]], ndarray[Any, dtype[int64]], Any]:
    """
    Find the intersections between a group of triangles and rays

    Parameters
    -------------
    triangles : (n, 3, 3) float
      Triangles in space
    ray_origins : (m, 3) float
      Ray origin points
    ray_directions : (m, 3) float
      Ray direction vectors
    triangles_normal : (n, 3) float
      Normal vector of triangles, optional
    tree : rtree.Index
      Rtree object holding triangle bounds

    Returns
    -----------
    index_triangle : (h,) int
      Index of triangles hit
    index_ray : (h,) int
      Index of ray that hit triangle
    locations : (h, 3) float
      Position of intersection in space
    """
    ...

def ray_triangle_candidates(ray_origins, ray_directions, tree):  # -> tuple[NDArray[int64], NDArray[int64]]:
    """
    Do broad- phase search for triangles that the rays
    may intersect.

    Does this by creating a bounding box for the ray as it
    passes through the volume occupied by the tree

    Parameters
    ------------
    ray_origins : (m, 3) float
      Ray origin points.
    ray_directions : (m, 3) float
      Ray direction vectors
    tree : rtree object
      Ccontains AABB of each triangle

    Returns
    ----------
    ray_candidates : (n,) int
      Triangle indexes
    ray_id : (n,) int
      Corresponding ray index for a triangle candidate
    """
    ...

def ray_bounds(ray_origins, ray_directions, bounds, buffer_dist=...):  # -> NDArray[floating[Any]]:
    """
    Given a set of rays and a bounding box for the volume of interest
    where the rays will be passing through, find the bounding boxes
    of the rays as they pass through the volume.

    Parameters
    ------------
    ray_origins:      (m,3) float, ray origin points
    ray_directions:   (m,3) float, ray direction vectors
    bounds:           (2,3) bounding box (min, max)
    buffer_dist:      float, distance to pad zero width bounding boxes

    Returns
    ---------
    ray_bounding: (n) set of AABB of rays passing through volume
    """
    ...

"""
This type stub file was generated by pyright.
"""

from .. import caching, units
from ..parent import Geometry3D

class Scene(Geometry3D):
    """
    A simple scene graph which can be rendered directly via
    pyglet/openGL or through other endpoints such as a
    raytracer. Meshes are added by name, which can then be
    moved by updating transform in the transform tree.
    """

    def __init__(
        self, geometry=..., base_frame=..., metadata=..., graph=..., camera=..., lights=..., camera_transform=...
    ) -> None:
        """
        Create a new Scene object.

        Parameters
        -------------
        geometry : Trimesh, Path2D, Path3D PointCloud or list
          Geometry to initially add to the scene
        base_frame : str or hashable
          Name of base frame
        metadata : dict
          Any metadata about the scene
        graph : TransformForest or None
          A passed transform graph to use
        camera : Camera or None
          A passed camera to use
        lights : [trimesh.scene.lighting.Light] or None
          A passed lights to use
        camera_transform : (4, 4) float or None
          Camera transform in the base frame
        """
        ...
    def apply_transform(self, transform):  # -> Self@Scene:
        """
        Apply a transform to all children of the base frame
        without modifying any geometry.

        Parameters
        --------------
        transform : (4, 4)
          Homogeneous transformation matrix.
        """
        ...
    def add_geometry(
        self, geometry, node_name=..., geom_name=..., parent_node_name=..., transform=..., metadata=...
    ):  # -> list[Unknown] | dict[Unknown, Unknown] | str | None:
        """
        Add a geometry to the scene.

        If the mesh has multiple transforms defined in its
        metadata, they will all be copied into the
        TransformForest of the current scene automatically.

        Parameters
        ----------
        geometry : Trimesh, Path2D, Path3D PointCloud or list
          Geometry to initially add to the scene
        node_name : None or str
          Name of the added node.
        geom_name : None or str
          Name of the added geometry.
        parent_node_name : None or str
          Name of the parent node in the graph.
        transform : None or (4, 4) float
          Transform that applies to the added node.
        metadata : None or dict
          Optional metadata for the node.

        Returns
        ----------
        node_name : str
          Name of single node in self.graph (passed in) or None if
          node was not added (eg. geometry was null or a Scene).
        """
        ...
    def delete_geometry(self, names):  # -> None:
        """
        Delete one more multiple geometries from the scene and also
        remove any node in the transform graph which references it.

        Parameters
        --------------
        name : hashable
          Name that references self.geometry
        """
        ...
    def strip_visuals(self):  # -> None:
        """
        Strip visuals from every Trimesh geometry
        and set them to an empty `ColorVisuals`.
        """
        ...
    def __hash__(self) -> int:
        """
        Return information about scene which is hashable.

        Returns
        ---------
        hashable : str
          Data which can be hashed.
        """
        ...
    @property
    def is_empty(self):  # -> bool:
        """
        Does the scene have anything in it.

        Returns
        ----------
        is_empty: bool, True if nothing is in the scene
        """
        ...
    @property
    def is_valid(self):  # -> bool:
        """
        Is every geometry connected to the root node.

        Returns
        -----------
        is_valid : bool
          Does every geometry have a transform
        """
        ...
    @caching.cache_decorator
    def bounds_corners(self):  # -> dict[Unknown, Unknown]:
        """
        Get the post-transform AABB for each node
        which has geometry defined.

        Returns
        -----------
        corners : dict
          Bounds for each node with vertices:
           {node_name : (2, 3) float}
        """
        ...
    @caching.cache_decorator
    def bounds(self):  # -> NDArray[float64] | None:
        """
        Return the overall bounding box of the scene.

        Returns
        --------
        bounds : (2, 3) float or None
          Position of [min, max] bounding box
          Returns None if no valid bounds exist
        """
        ...
    @caching.cache_decorator
    def extents(self):  # -> ndarray[Any, dtype[Any]]:
        """
        Return the axis aligned box size of the current scene.

        Returns
        ----------
        extents : (3,) float
          Bounding box sides length
        """
        ...
    @caching.cache_decorator
    def scale(self):  # -> Any:
        """
        The approximate scale of the mesh

        Returns
        -----------
        scale : float
          The mean of the bounding box edge lengths
        """
        ...
    @caching.cache_decorator
    def centroid(self):  # -> Any:
        """
        Return the center of the bounding box for the scene.

        Returns
        --------
        centroid : (3) float
          Point for center of bounding box
        """
        ...
    @caching.cache_decorator
    def center_mass(self):  # -> Any:
        """
        Find the center of mass for every instance in the scene.

        Returns
        ------------
        center_mass : (3,) float
          The center of mass of the scene
        """
        ...
    @caching.cache_decorator
    def moment_inertia(self):  # -> Any:
        """
        Return the moment of inertia of the current scene with
        respect to the center of mass of the current scene.

        Returns
        ------------
        inertia : (3, 3) float
          Inertia with respect to cartesian axis at `scene.center_mass`
        """
        ...
    def moment_inertia_frame(self, transform):  # -> Any:
        """
        Return the moment of inertia of the current scene relative
        to a transform from the base frame.

        Parameters
        transform : (4, 4) float
          Homogeneous transformation matrix.

        Returns
        -------------
        inertia : (3, 3) float
          Inertia tensor at requested frame.
        """
        ...
    @caching.cache_decorator
    def area(self):  # -> float:
        """
        What is the summed area of every geometry which
        has area.

        Returns
        ------------
        area : float
          Summed area of every instanced geometry
        """
        ...
    @caching.cache_decorator
    def volume(self):  # -> float:
        """
        What is the summed volume of every geometry which
        has volume

        Returns
        ------------
        volume : float
          Summed area of every instanced geometry
        """
        ...
    @caching.cache_decorator
    def triangles(self):  # -> ndarray[Any, dtype[Unknown]]:
        """
        Return a correctly transformed polygon soup of the
        current scene.

        Returns
        ----------
        triangles : (n, 3, 3) float
          Triangles in space
        """
        ...
    @caching.cache_decorator
    def triangles_node(self):  # -> None:
        """
        Which node of self.graph does each triangle come from.

        Returns
        ---------
        triangles_index : (len(self.triangles),)
          Node name for each triangle
        """
        ...
    @caching.cache_decorator
    def geometry_identifiers(self):  # -> dict[Unknown, Unknown]:
        """
        Look up geometries by identifier hash

        Returns
        ---------
        identifiers : dict
          {Identifier hash: key in self.geometry}
        """
        ...
    @caching.cache_decorator
    def duplicate_nodes(self):  # -> list[Unknown] | list[list[Unknown]]:
        """
        Return a sequence of node keys of identical meshes.

        Will include meshes with different geometry but identical
        spatial hashes as well as meshes repeated by self.nodes.

        Returns
        -----------
        duplicates : (m) sequence
          Keys of self.graph that represent identical geometry
        """
        ...
    def deduplicated(self):  # -> Scene:
        """
        Return a new scene where each unique geometry is only
        included once and transforms are discarded.

        Returns
        -------------
        dedupe : Scene
          One copy of each unique geometry from scene
        """
        ...
    def set_camera(self, angles=..., distance=..., center=..., resolution=..., fov=...):  # -> Camera:
        """
        Create a camera object for self.camera, and add
        a transform to self.graph for it.

        If arguments are not passed sane defaults will be figured
        out which show the mesh roughly centered.

        Parameters
        -----------
        angles : (3,) float
          Initial euler angles in radians
        distance : float
          Distance from centroid
        center : (3,) float
          Point camera should be center on
        camera : Camera object
          Object that stores camera parameters
        """
        ...
    @property
    def camera_transform(self):  # -> NDArray[float64] | Any:
        """
        Get camera transform in the base frame.

        Returns
        -------
        camera_transform : (4, 4) float
          Camera transform in the base frame
        """
        ...
    @camera_transform.setter
    def camera_transform(self, matrix):  # -> None:
        """
        Set the camera transform in the base frame

        Parameters
        ----------
        camera_transform : (4, 4) float
          Camera transform in the base frame
        """
        ...
    def camera_rays(self):  # -> tuple[NDArray[floating[Any]] | Any, NDArray[float64] | Any, NDArray[int64] | Unknown]:
        """
        Calculate the trimesh.scene.Camera origin and ray
        direction vectors. Returns one ray per pixel as set
        in camera.resolution

        Returns
        --------------
        origin: (n, 3) float
          Ray origins in space
        vectors: (n, 3) float
          Ray direction unit vectors in world coordinates
        pixels : (n, 2) int
          Which pixel does each ray correspond to in an image
        """
        ...
    @property
    def camera(self):  # -> Camera:
        """
        Get the single camera for the scene. If not manually
        set one will abe automatically generated.

        Returns
        ----------
        camera : trimesh.scene.Camera
          Camera object defined for the scene
        """
        ...
    @camera.setter
    def camera(self, camera):  # -> None:
        """
        Set a camera object for the Scene.

        Parameters
        -----------
        camera : trimesh.scene.Camera
          Camera object for the scene
        """
        ...
    @property
    def has_camera(self):  # -> bool:
        ...
    @property
    def lights(self):  # -> list[PointLight]:
        """
        Get a list of the lights in the scene. If nothing is
        set it will generate some automatically.

        Returns
        -------------
        lights : [trimesh.scene.lighting.Light]
          Lights in the scene.
        """
        ...
    @lights.setter
    def lights(self, lights):  # -> None:
        """
        Assign a list of light objects to the scene

        Parameters
        --------------
        lights : [trimesh.scene.lighting.Light]
          Lights in the scene.
        """
        ...
    def rezero(self):  # -> None:
        """
        Move the current scene so that the AABB of the whole
        scene is centered at the origin.

        Does this by changing the base frame to a new, offset
        base frame.
        """
        ...
    def dump(self, concatenate=...):  # -> list[Unknown] | Any | NDArray[Unknown]:
        """
        Append all meshes in scene freezing transforms.

        Parameters
        ------------
        concatenate : bool
          If True, concatenate results into single mesh

        Returns
        ----------
        dumped : (n,) Trimesh, Path2D, Path3D, PointCloud
          Depending on what the scene contains. If `concatenate`
          then some geometry may be dropped if it doesn't match.
        """
        ...
    def subscene(self, node):  # -> Scene:
        """
        Get part of a scene that succeeds a specified node.

        Parameters
        ------------
        node : any
          Hashable key in `scene.graph`

        Returns
        -----------
        subscene : Scene
          Partial scene generated from current.
        """
        ...
    @caching.cache_decorator
    def convex_hull(self):  # -> Trimesh:
        """
        The convex hull of the whole scene

        Returns
        ---------
        hull: Trimesh object, convex hull of all meshes in scene
        """
        ...
    def export(
        self, file_obj=..., file_type=..., **kwargs
    ):  # -> dict[Unknown, Unknown] | dict[str, Unknown] | bytes | bytearray | memoryview | LiteralString | str | Any:
        """
        Export a snapshot of the current scene.

        Parameters
        ----------
        file_obj : str, file-like, or None
          File object to export to
        file_type : str or None
          What encoding to use for meshes
          IE: dict, dict64, stl

        Returns
        ----------
        export : bytes
          Only returned if file_obj is None
        """
        ...
    def save_image(self, resolution=..., **kwargs):  # -> bytes:
        """
        Get a PNG image of a scene.

        Parameters
        -----------
        resolution : (2,) int
          Resolution to render image
        **kwargs
          Passed to SceneViewer constructor

        Returns
        -----------
        png : bytes
          Render of scene as a PNG
        """
        ...
    @property
    def units(self) -> str:
        """
        Get the units for every model in the scene, and
        raise a ValueError if there are mixed units.

        Returns
        -----------
        units : str
          Units for every model in the scene
        """
        ...
    @units.setter
    def units(self, value: str):  # -> None:
        """
        Set the units for every model in the scene without
        converting any units just setting the tag.

        Parameters
        ------------
        value : str
          Value to set every geometry unit value to
        """
        ...
    def convert_units(self, desired: str, guess: bool = ...) -> Scene:
        """
        If geometry has units defined convert them to new units.

        Returns a new scene with geometries and transforms scaled.

        Parameters
        ----------
        desired : str
          Desired final unit system: 'inches', 'mm', etc.
        guess : bool
          Is the converter allowed to guess scale when models
          don't have it specified in their metadata.

        Returns
        ----------
        scaled : trimesh.Scene
          Copy of scene with scaling applied and units set
          for every model
        """
        ...
    def explode(self, vector=..., origin=...):  # -> None:
        """
        Explode a scene around a point and vector.

        Parameters
        -----------
        vector : (3,) float or float
           Explode radially around a direction vector or spherically
        origin : (3,) float
          Point to explode around
        """
        ...
    def scaled(self, scale):  # -> Scene:
        """
        Return a copy of the current scene, with meshes and scene
        transforms scaled to the requested factor.

        Parameters
        -----------
        scale : float or (3,) float
          Factor to scale meshes and transforms

        Returns
        -----------
        scaled : trimesh.Scene
          A copy of the current scene but scaled
        """
        ...
    def copy(self):  # -> Scene:
        """
        Return a deep copy of the current scene

        Returns
        ----------
        copied : trimesh.Scene
          Copy of the current scene
        """
        ...
    def show(self, viewer=..., **kwargs):  # -> SceneViewer:
        """
        Display the current scene.

        Parameters
        -----------
        viewer : Union[str, callable, None]
          What kind of viewer to use, such as
          'gl' to open a pyglet window, 'notebook'
          for a jupyter notebook or None
        kwargs : dict
          Includes `smooth`, which will turn
          on or off automatic smooth shading
        """
        ...
    def __add__(self, other):  # -> Scene:
        """
        Concatenate the current scene with another scene or mesh.

        Parameters
        ------------
        other : trimesh.Scene, trimesh.Trimesh, trimesh.Path
           Other object to append into the result scene

        Returns
        ------------
        appended : trimesh.Scene
           Scene with geometry from both scenes
        """
        ...

def split_scene(geometry, **kwargs):  # -> Scene:
    """
    Given a geometry, list of geometries, or a Scene
    return them as a single Scene object.

    Parameters
    ----------
    geometry : splittable

    Returns
    ---------
    scene: trimesh.Scene
    """
    ...

def append_scenes(iterable, common=..., base_frame=...):  # -> Scene:
    """
    Concatenate multiple scene objects into one scene.

    Parameters
    -------------
    iterable : (n,) Trimesh or Scene
       Geometries that should be appended
    common : (n,) str
       Nodes that shouldn't be remapped
    base_frame : str
       Base frame of the resulting scene

    Returns
    ------------
    result : trimesh.Scene
       Scene containing all geometry
    """
    ...

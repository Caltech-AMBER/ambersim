"""
This type stub file was generated by pyright.
"""

import abc

from .. import caching
from ..util import ABC

"""OO interfaces to encodings for ND arrays which caching."""

class Encoding(ABC):
    """
    Base class for objects that implement a specific subset of of ndarray ops.

    This presents a unified interface for various different ways of encoding
    conceptually dense arrays and to interoperate between them.

    Example implementations are ND sparse arrays, run length encoded arrays
    and dense encodings (wrappers around np.ndarrays).
    """

    def __init__(self, data) -> None: ...
    @abc.abstractproperty
    def dtype(self):  # -> None:
        ...
    @abc.abstractproperty
    def shape(self):  # -> None:
        ...
    @abc.abstractproperty
    def sum(self):  # -> None:
        ...
    @abc.abstractproperty
    def size(self):  # -> None:
        ...
    @abc.abstractproperty
    def sparse_indices(self):  # -> None:
        ...
    @abc.abstractproperty
    def sparse_values(self):  # -> None:
        ...
    @abc.abstractproperty
    def dense(self):  # -> None:
        ...
    @abc.abstractmethod
    def gather_nd(self, indices):  # -> None:
        ...
    @abc.abstractmethod
    def mask(self, mask):  # -> None:
        ...
    @abc.abstractmethod
    def get_value(self, index):  # -> None:
        ...
    @abc.abstractmethod
    def copy(self):  # -> None:
        ...
    @property
    def is_empty(self): ...
    @caching.cache_decorator
    def stripped(self):  # -> tuple[DenseEncoding, NDArray[Any]]:
        """
        Get encoding with all zeros stripped from the start and end
        of each axis.

        Returns
        ------------
        encoding: ?
        padding : (n, 2) int
          Padding at the start and end that was stripped
        """
        ...
    def __hash__(self) -> int:
        """
        Get the hash of the current transformation matrix.

        Returns
        ------------
        hash : str
          Hash of transformation matrix
        """
        ...
    @property
    def ndims(self):  # -> int:
        ...
    def reshape(self, shape):  # -> FlattenedEncoding | ShapedEncoding:
        ...
    @property
    def flat(self):  # -> FlattenedEncoding:
        ...
    def flip(self, axis=...):  # -> Self@Encoding | FlippedEncoding:
        ...
    @property
    def sparse_components(self):  # -> tuple[None, None]:
        ...
    @property
    def data(self):  # -> Unknown:
        ...
    def run_length_data(self, dtype=...):  # -> ndarray[Any, dtype[int64]]:
        ...
    def binary_run_length_data(self, dtype=...):  # -> NDArray[int64] | NDArray[Unknown]:
        ...
    def transpose(self, perm):  # -> Self@Encoding | TransposedEncoding:
        ...
    @property
    def mutable(self): ...
    @mutable.setter
    def mutable(self, value):  # -> None:
        ...

class DenseEncoding(Encoding):
    """Simple `Encoding` implementation based on a numpy ndarray."""

    def __init__(self, data) -> None: ...
    @property
    def dtype(self): ...
    @property
    def shape(self): ...
    @caching.cache_decorator
    def sum(self): ...
    @caching.cache_decorator
    def is_empty(self):  # -> bool:
        ...
    @property
    def size(self): ...
    @property
    def sparse_components(self):  # -> tuple[Any, Unknown]:
        ...
    @caching.cache_decorator
    def sparse_indices(self):  # -> NDArray[intp]:
        ...
    @caching.cache_decorator
    def sparse_values(self): ...
    @property
    def dense(self):  # -> Unknown:
        ...
    def gather(self, indices): ...
    def gather_nd(self, indices): ...
    def mask(self, mask): ...
    def get_value(self, index): ...
    def reshape(self, shape):  # -> DenseEncoding:
        ...
    @property
    def flat(self):  # -> DenseEncoding:
        ...
    def copy(self):  # -> DenseEncoding:
        ...

class SparseEncoding(Encoding):
    """
    `Encoding` implementation based on an ND sparse implementation.

    Since the scipy.sparse implementations are for 2D arrays only, this
    implementation uses a single-column CSC matrix with index
    raveling/unraveling.
    """

    def __init__(self, indices, values, shape=...) -> None:
        """
        Parameters
        ------------
        indices: (m, n)-sized int array of indices
        values: (m, n)-sized dtype array of values at the specified indices
        shape: (n,) iterable of integers. If None, the maximum value of indices
            + 1 is used.
        """
        ...
    @staticmethod
    def from_dense(dense_data):  # -> SparseEncoding:
        ...
    def copy(self):  # -> SparseEncoding:
        ...
    @property
    def sparse_indices(self): ...
    @property
    def sparse_values(self): ...
    @property
    def dtype(self): ...
    @caching.cache_decorator
    def sum(self): ...
    @property
    def ndims(self): ...
    @property
    def shape(self):  # -> tuple[Unknown, ...]:
        ...
    @property
    def size(self):  # -> int_:
        ...
    @property
    def sparse_components(self):  # -> tuple[Unknown, Unknown]:
        ...
    @caching.cache_decorator
    def dense(self):  # -> NDArray[float64]:
        ...
    def gather_nd(self, indices):  # -> ndarray[Any, dtype[Any]]:
        ...
    def mask(self, mask): ...
    def get_value(self, index): ...
    @caching.cache_decorator
    def stripped(self):  # -> tuple[DenseEncoding, NDArray[Any]] | tuple[SparseEncoding, NDArray[Any]]:
        """
        Get encoding with all zeros stripped from the start/end of each axis.

        Returns:
            encoding: SparseEncoding with same values but indices shifted down
                by padding[:, 0]
            padding: (n, 2) array of ints denoting padding at the start/end
                that was stripped
        """
        ...

def SparseBinaryEncoding(indices, shape=...):  # -> SparseEncoding:
    """
    Convenient factory constructor for SparseEncodings with values all ones.

    Parameters
    ------------
    indices: (m, n) sparse indices into conceptual rank-n array
    shape: length n iterable or None. If None, maximum of indices along first
        axis + 1 is used

    Returns
    ------------
    rank n bool `SparseEncoding` with True values at each index.
    """
    ...

class RunLengthEncoding(Encoding):
    """1D run length encoding.

    See `trimesh.voxel.runlength` documentation for implementation details.
    """

    def __init__(self, data, dtype=...) -> None:
        """
        Parameters
        ------------
        data: run length encoded data.
        dtype: dtype of encoded data. Each second value of data is cast will be
            cast to this dtype if provided.
        """
        ...
    @caching.cache_decorator
    def is_empty(self):  # -> bool:
        ...
    @property
    def ndims(self):  # -> Literal[1]:
        ...
    @property
    def shape(self):  # -> tuple[Any]:
        ...
    @property
    def dtype(self): ...
    def __hash__(self) -> int:
        """
        Get the hash of the current transformation matrix.

        Returns
        ------------
        hash : str
          Hash of transformation matrix
        """
        ...
    @staticmethod
    def from_dense(dense_data, dtype=..., encoding_dtype=...):  # -> RunLengthEncoding:
        ...
    @staticmethod
    def from_rle(rle_data, dtype=...):  # -> RunLengthEncoding:
        ...
    @staticmethod
    def from_brle(brle_data, dtype=...):  # -> RunLengthEncoding:
        ...
    @caching.cache_decorator
    def stripped(
        self,
    ):  # -> tuple[DenseEncoding, NDArray[Any]] | tuple[Self@RunLengthEncoding | RunLengthEncoding, NDArray[Any]]:
        ...
    @caching.cache_decorator
    def sum(self): ...
    @caching.cache_decorator
    def size(self): ...
    @caching.cache_decorator
    def sparse_components(self):  # -> tuple[list[Unknown], list[Unknown]] | tuple[NDArray[Unknown], NDArray[Unknown]]:
        ...
    @caching.cache_decorator
    def sparse_indices(self):  # -> Any:
        ...
    @caching.cache_decorator
    def sparse_values(self):  # -> Any:
        ...
    @caching.cache_decorator
    def dense(self):  # -> NDArray[int64]:
        ...
    def gather(self, indices):  # -> NDArray[float64]:
        ...
    def gather_nd(self, indices):  # -> NDArray[float64]:
        ...
    def sorted_gather(self, ordered_indices):  # -> NDArray[Unknown]:
        ...
    def mask(self, mask):  # -> NDArray[Unknown]:
        ...
    def get_value(self, index):  # -> Any | None:
        ...
    def copy(self):  # -> RunLengthEncoding:
        ...
    def run_length_data(self, dtype=...):  # -> ndarray[Any, dtype[int64]]:
        ...
    def binary_run_length_data(self, dtype=...):  # -> NDArray[int64] | NDArray[Unknown] | NDArray[Any] | list[int]:
        ...

class BinaryRunLengthEncoding(RunLengthEncoding):
    """1D binary run length encoding.

    See `trimesh.voxel.runlength` documentation for implementation details.
    """

    def __init__(self, data) -> None:
        """
        Parameters
        ------------
        data: binary run length encoded data.
        """
        ...
    @caching.cache_decorator
    def is_empty(self):  # -> bool:
        ...
    @staticmethod
    def from_dense(dense_data, encoding_dtype=...):  # -> BinaryRunLengthEncoding:
        ...
    @staticmethod
    def from_rle(rle_data, dtype=...):  # -> BinaryRunLengthEncoding:
        ...
    @staticmethod
    def from_brle(brle_data, dtype=...):  # -> BinaryRunLengthEncoding:
        ...
    @caching.cache_decorator
    def stripped(
        self,
    ):  # -> tuple[DenseEncoding, NDArray[Any]] | tuple[Self@BinaryRunLengthEncoding | BinaryRunLengthEncoding, NDArray[Any]]:
        ...
    @caching.cache_decorator
    def sum(self): ...
    @caching.cache_decorator
    def size(self): ...
    @property
    def sparse_components(self):  # -> tuple[Any, Any]:
        ...
    @caching.cache_decorator
    def sparse_values(self):  # -> NDArray[Any]:
        ...
    @caching.cache_decorator
    def sparse_indices(self):  # -> NDArray[int64]:
        ...
    @caching.cache_decorator
    def dense(self):  # -> ndarray[Any, dtype[Any]]:
        ...
    def gather(self, indices):  # -> NDArray[float64]:
        ...
    def gather_nd(self, indices):  # -> NDArray[float64]:
        ...
    def sorted_gather(self, ordered_indices):  # -> NDArray[Any]:
        ...
    def mask(self, mask):  # -> NDArray[Any]:
        ...
    def copy(self):  # -> BinaryRunLengthEncoding:
        ...
    def run_length_data(self, dtype=...):  # -> ndarray[Any, dtype[int64]]:
        ...
    def binary_run_length_data(self, dtype=...):  # -> NDArray[int64] | NDArray[Unknown] | NDArray[Any]:
        ...

class LazyIndexMap(Encoding):
    """
    Abstract class for implementing lazy index mapping operations.

    Implementations include transpose, flatten/reshaping and flipping

    Derived classes must implement:
        * _to_base_indices(indices)
        * _from_base_indices(base_indices)
        * shape
        * dense
        * mask(mask)
    """

    @property
    def is_empty(self): ...
    @property
    def dtype(self): ...
    @property
    def sum(self): ...
    @property
    def size(self): ...
    @property
    def sparse_indices(self):  # -> None:
        ...
    @property
    def sparse_values(self): ...
    def gather_nd(self, indices): ...
    def get_value(self, index): ...

class FlattenedEncoding(LazyIndexMap):
    """
    Lazily flattened encoding.

    Dense equivalent is np.reshape(data, (-1,)) (np.flatten creates a copy).
    """

    @property
    def shape(self):  # -> tuple[Unknown]:
        ...
    @property
    def dense(self): ...
    def mask(self, mask): ...
    @property
    def flat(self):  # -> Self@FlattenedEncoding:
        ...
    def copy(self):  # -> FlattenedEncoding:
        ...

class ShapedEncoding(LazyIndexMap):
    """
    Lazily reshaped encoding.

    Numpy equivalent is `np.reshape`
    """

    def __init__(self, encoding, shape) -> None: ...
    @property
    def flat(self):  # -> Unknown:
        ...
    @property
    def shape(self):  # -> tuple[Unknown, ...]:
        ...
    @property
    def dense(self): ...
    def mask(self, mask): ...
    def copy(self):  # -> ShapedEncoding:
        ...

class TransposedEncoding(LazyIndexMap):
    """
    Lazily transposed encoding

    Dense equivalent is `np.transpose`
    """

    def __init__(self, base_encoding, perm) -> None: ...
    def transpose(self, perm):  # -> Unknown:
        ...
    @property
    def perm(self):  # -> NDArray[int64]:
        ...
    @property
    def shape(self):  # -> tuple[Unknown, ...]:
        ...
    @property
    def dense(self): ...
    def gather(self, indices): ...
    def mask(self, mask): ...
    def get_value(self, index): ...
    @property
    def data(self):  # -> Unknown:
        ...
    def copy(self):  # -> TransposedEncoding:
        ...

class FlippedEncoding(LazyIndexMap):
    """
    Encoding with entries flipped along one or more axes.

    Dense equivalent is `np.flip`
    """

    def __init__(self, encoding, axes) -> None: ...
    @property
    def shape(self): ...
    @property
    def dense(self):  # -> NDArray[Unknown]:
        ...
    def mask(self, mask): ...
    def copy(self):  # -> FlippedEncoding:
        ...
    def flip(self, axis=...):  # -> Self@FlippedEncoding:
        ...

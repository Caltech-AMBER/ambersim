"""
This type stub file was generated by pyright.
"""

from typing import Optional, Tuple, Union

import jax
from jax import numpy as jp

"""Some useful math functions."""

def norm(x: jax.Array, axis: Optional[Union[Tuple[int, ...], int]] = ...) -> jax.Array:
    """Calculates a linalg.norm(x) that's safe for gradients at x=0.

    Avoids a poorly defined gradient for jnp.linal.norm(0) see
    https://github.com/google/jax/issues/3058 for details
    Args:
      x: A jnp.array
      axis: The axis along which to compute the norm

    Returns:
      Norm of the array x.
    """
    ...

def normalize_with_norm(x: jax.Array, axis: Optional[Union[Tuple[int, ...], int]] = ...) -> Tuple[jax.Array, jax.Array]:
    """Normalizes an array.

    Args:
      x: A jnp.array
      axis: The axis along which to compute the norm

    Returns:
      A tuple of (normalized array x, the norm).
    """
    ...

def normalize(x: jax.Array, axis: Optional[Union[Tuple[int, ...], int]] = ...) -> jax.Array:
    """Normalizes an array.

    Args:
      x: A jnp.array
      axis: The axis along which to compute the norm

    Returns:
      normalized array x
    """
    ...

def rotate(vec: jax.Array, quat: jax.Array) -> jax.Array:
    """Rotates a vector vec by a unit quaternion quat.

    Args:
      vec: (3,) a vector
      quat: (4,) a quaternion

    Returns:
      ndarray(3) containing vec rotated by quat.
    """
    ...

def quat_inv(q: jp.ndarray) -> jp.ndarray:
    """Calculates the inverse of quaternion q.

    Args:
      q: (4,) quaternion [w, x, y, z]

    Returns:
      The inverse of q, where qmult(q, inv_quat(q)) = [1, 0, 0, 0].
    """
    ...

def quat_sub(u: jax.Array, v: jax.Array) -> jax.Array:
    """Subtracts two quaternions (u - v) as a 3D velocity."""
    ...

def quat_mul(u: jax.Array, v: jax.Array) -> jax.Array:
    """Multiplies two quaternions.

    Args:
      u: (4,) quaternion (w,x,y,z)
      v: (4,) quaternion (w,x,y,z)

    Returns:
      A quaternion u * v.
    """
    ...

def quat_mul_axis(q: jax.Array, axis: jax.Array) -> jax.Array:
    """Multiplies a quaternion and an axis.

    Args:
      q: (4,) quaternion (w,x,y,z)
      axis: (3,) axis (x,y,z)

    Returns:
      A quaternion q * axis
    """
    ...

def quat_to_mat(q: jax.Array) -> jax.Array:
    """Converts a quaternion into a 9-dimensional rotation matrix."""
    ...

def quat_to_axis_angle(q: jax.Array) -> Tuple[jax.Array, jax.Array]:
    """Converts a quaternion into axis and angle."""
    ...

def axis_angle_to_quat(axis: jax.Array, angle: jax.Array) -> jax.Array:
    """Provides a quaternion that describes rotating around axis by angle.

    Args:
      axis: (3,) axis (x,y,z)
      angle: () float angle to rotate by

    Returns:
      A quaternion that rotates around axis by angle
    """
    ...

def quat_integrate(q: jax.Array, v: jax.Array, dt: jax.Array) -> jax.Array:
    """Integrates a quaternion given angular velocity and dt."""
    ...

def inert_mul(i: jax.Array, v: jax.Array) -> jax.Array:
    """Multiply inertia by motion, producing force.

    Args:
      i: (10,) inertia (inertia matrix, position, mass)
      v: (6,) spatial motion

    Returns:
      resultant force
    """
    ...

def transform_motion(vel: jax.Array, offset: jax.Array, rotmat: jax.Array):  # -> Array:
    """Transform spatial motion.

    Args:
      vel: (6,) spatial motion (3 angular, 3 linear)
      offset: (3,) translation
      rotmat: (3, 3) rotation

    Returns:
      6d spatial velocity
    """
    ...

def motion_cross(u, v):  # -> Array:
    """Cross product of two motions.

    Args:
      u: (6,) spatial motion
      v: (6,) spatial motion

    Returns:
      resultant spatial motion
    """
    ...

def motion_cross_force(v, f):  # -> Array:
    """Cross product of a motion and force.

    Args:
      v: (6,) spatial motion
      f: (6,) force

    Returns:
      resultant force
    """
    ...

def orthogonals(a: jax.Array) -> Tuple[jax.Array, jax.Array]:
    """Returns orthogonal vectors `b` and `c`, given a vector `a`."""
    ...

def make_frame(a: jax.Array) -> jax.Array:
    """Makes a right-handed 3D frame given a direction."""
    ...

def closest_segment_point(a: jax.Array, b: jax.Array, pt: jax.Array) -> jax.Array:
    """Returns the closest point on the a-b line segment to a point pt."""
    ...

def closest_segment_point_and_dist(a: jax.Array, b: jax.Array, pt: jax.Array) -> Tuple[jax.Array, jax.Array]:
    """Returns closest point on the line segment and the distance squared."""
    ...

def closest_segment_to_segment_points(
    a0: jax.Array, a1: jax.Array, b0: jax.Array, b1: jax.Array
) -> Tuple[jax.Array, jax.Array]:
    """Returns closest points between two line segments."""
    ...
